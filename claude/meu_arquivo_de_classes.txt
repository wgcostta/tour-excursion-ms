//pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.3</version>
        <relativePath/>
    </parent>
    
    <groupId>br.com.tourapp</groupId>
    <artifactId>tourapp-backend</artifactId>
    <version>1.0.0</version>
    <name>TourApp Backend</name>
    <description>Sistema de gerenciamento de excursões</description>
    
    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.6</version>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Mercado Pago SDK -->
        <dependency>
            <groupId>com.mercadopago</groupId>
            <artifactId>sdk-java</artifactId>
            <version>2.1.29</version>
        </dependency>
        
        <!-- Cloudinary -->
        <dependency>
            <groupId>com.cloudinary</groupId>
            <artifactId>cloudinary-http45</artifactId>
            <version>2.5.1</version>
        </dependency>
        
        <!-- Firebase Admin -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.4.1</version>
        </dependency>
        
        <!-- Utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>3.2.1</version>
        </dependency>
        
        <!-- Micrometer para métricas -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>
        
        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <configuration>
                    <url>${DB_URL}</url>
                    <user>${DB_USER}</user>
                    <password>${DB_PASSWORD}</password>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

//src/main/resources/application.yml
spring:
  application:
    name: tourapp
  
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  
  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/tourapp}
    username: ${DB_USER:tourapp}
    password: ${DB_PASSWORD:tourapp123}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      connection-timeout: 20000
      validation-timeout: 5000
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
        use_sql_comments: true
    defer-datasource-initialization: false
  
  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration
    validate-on-migrate: true
  
  mail:
    host: ${MAIL_HOST:smtp.gmail.com}
    port: ${MAIL_PORT:587}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
  
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  
  # Virtual Threads (JDK 21 feature)
  threads:
    virtual:
      enabled: true

server:
  port: ${PORT:8080}
  servlet:
    context-path: /api
  # Habilitar HTTP/2 e compressão
  http2:
    enabled: true
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css
  error:
    include-stacktrace: never
    include-exception: false

# Configurações customizadas
app:
  jwt:
    secret: ${JWT_SECRET:tourapp-super-secret-key-change-in-production}
    expiration: ${JWT_EXPIRATION:86400000} # 24 horas em ms
  
  cors:
    allowed-origins: ${CORS_ORIGINS:http://localhost:3000,https://tourapp.vercel.app}
    allowed-methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
    allowed-headers: "*"
    allow-credentials: true
  
  mercadopago:
    access-token: ${MERCADOPAGO_ACCESS_TOKEN:}
    public-key: ${MERCADOPAGO_PUBLIC_KEY:}
    webhook-secret: ${MERCADOPAGO_WEBHOOK_SECRET:}
    sandbox: ${MERCADOPAGO_SANDBOX:true}
  
  cloudinary:
    cloud-name: ${CLOUDINARY_CLOUD_NAME:}
    api-key: ${CLOUDINARY_API_KEY:}
    api-secret: ${CLOUDINARY_API_SECRET:}
    secure: true
  
  firebase:
    service-account-path: ${FIREBASE_SERVICE_ACCOUNT_PATH:classpath:firebase-service-account.json}
  
  frontend:
    base-url: ${FRONTEND_BASE_URL:http://localhost:3000}
  
  file:
    upload-dir: ${UPLOAD_DIR:./uploads}
  
  cache:
    enabled: ${CACHE_ENABLED:true}
    ttl: ${CACHE_TTL:3600} # 1 hora

# Logging com melhor performance
logging:
  level:
    br.com.tourapp: ${LOG_LEVEL:INFO}
    org.springframework.security: ${SECURITY_LOG_LEVEL:WARN}
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: ${SQL_PARAMS_LOG_LEVEL:WARN}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: ${LOG_FILE:logs/tourapp.log}

# Management endpoints com security
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when_authorized
      show-components: when_authorized
    metrics:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

//src/main/java/br/com/tourapp/TourappApplication.java
package br.com.tourapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaAuditing
@EnableAsync
@EnableScheduling
public class TourappApplication {

    public static void main(String[] args) {
        SpringApplication.run(TourappApplication.class, args);
    }
}

//src/main/java/br/com/tourapp/entity/BaseEntity.java
package br.com.tourapp.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    // Getters e Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Long getVersion() {
        return version;
    }

    public void setVersion(Long version) {
        this.version = version;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BaseEntity)) return false;
        BaseEntity that = (BaseEntity) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}

//src/main/java/br/com/tourapp/enums/StatusOrganizador.java
package br.com.tourapp.enums;

public enum StatusOrganizador {
    PENDENTE("Pendente de aprovação"),
    ATIVO("Ativo"),
    INATIVO("Inativo"),
    SUSPENSO("Suspenso");

    private final String descricao;

    StatusOrganizador(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusExcursao.java
package br.com.tourapp.enums;

public enum StatusExcursao {
    RASCUNHO("Rascunho"),
    ATIVA("Ativa"),
    LOTADA("Lotada"),
    CANCELADA("Cancelada"),
    FINALIZADA("Finalizada");

    private final String descricao;

    StatusExcursao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusPagamento.java
package br.com.tourapp.enums;

public enum StatusPagamento {
    PENDENTE("Pendente"),
    PROCESSANDO("Processando"),
    APROVADO("Aprovado"),
    REJEITADO("Rejeitado"),
    CANCELADO("Cancelado"),
    REEMBOLSADO("Reembolsado"),
    EXPIRADO("Expirado");

    private final String descricao;

    StatusPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/MetodoPagamento.java
package br.com.tourapp.enums;

public enum MetodoPagamento {
    PIX("PIX"),
    CARTAO_CREDITO("Cartão de Crédito"),
    CARTAO_DEBITO("Cartão de Débito"),
    BOLETO("Boleto"),
    DINHEIRO("Dinheiro");

    private final String descricao;

    MetodoPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoNotificacao.java
package br.com.tourapp.enums;

public enum TipoNotificacao {
    INFO("Informação"),
    PROMOCAO("Promoção"),
    LEMBRETE("Lembrete"),
    URGENTE("Urgente"),
    CONFIRMACAO("Confirmação"),
    CANCELAMENTO("Cancelamento");

    private final String descricao;

    TipoNotificacao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoUsuario.java
package br.com.tourapp.enums;

public enum TipoUsuario {
    CLIENTE("Cliente"),
    ORGANIZADOR("Organizador"),
    ADMIN("Administrador");

    private final String descricao;

    TipoUsuario(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/entity/Cliente.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "clientes")
public class Cliente extends BaseEntity {

    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String nome;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "push_token")
    private String pushToken;

    @Column(name = "email_notifications", nullable = false)
    private Boolean emailNotifications = true;

    @Column(name = "sms_notifications", nullable = false)
    private Boolean smsNotifications = true;

    @Column(name = "ativo", nullable = false)
    private Boolean ativo = true;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.CLIENTE;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Cliente() {}

    public Cliente(String nome, String email, String senha) {
        this.nome = nome;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPushToken() { return pushToken; }
    public void setPushToken(String pushToken) { this.pushToken = pushToken; }

    public Boolean getEmailNotifications() { return emailNotifications; }
    public void setEmailNotifications(Boolean emailNotifications) { this.emailNotifications = emailNotifications; }

    public Boolean getSmsNotifications() { return smsNotifications; }
    public void setSmsNotifications(Boolean smsNotifications) { this.smsNotifications = smsNotifications; }

    public Boolean getAtivo() { return ativo; }
    public void setAtivo(Boolean ativo) { this.ativo = ativo; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Organizador.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusOrganizador;
import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "organizadores")
public class Organizador extends BaseEntity {

    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 150, message = "Nome da empresa deve ter entre 2 e 150 caracteres")
    @Column(name = "nome_empresa", nullable = false, length = 150)
    private String nomeEmpresa;

    @NotBlank(message = "Nome do responsável é obrigatório")
    @Size(min = 2, max = 100, message = "Nome do responsável deve ter entre 2 e 100 caracteres")
    @Column(name = "nome_responsavel", nullable = false, length = 100)
    private String nomeResponsavel;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "pix_key", length = 100)
    private String pixKey;

    @Size(max = 18, message = "CNPJ deve ter no máximo 18 caracteres")
    @Column(length = 18)
    private String cnpj;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusOrganizador status = StatusOrganizador.PENDENTE;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.ORGANIZADOR;

    @OneToMany(mappedBy = "organizador", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Excursao> excursoes;

    // Construtores
    public Organizador() {}

    public Organizador(String nomeEmpresa, String nomeResponsavel, String email, String senha) {
        this.nomeEmpresa = nomeEmpresa;
        this.nomeResponsavel = nomeResponsavel;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNomeEmpresa() { return nomeEmpresa; }
    public void setNomeEmpresa(String nomeEmpresa) { this.nomeEmpresa = nomeEmpresa; }

    public String getNomeResponsavel() { return nomeResponsavel; }
    public void setNomeResponsavel(String nomeResponsavel) { this.nomeResponsavel = nomeResponsavel; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPixKey() { return pixKey; }
    public void setPixKey(String pixKey) { this.pixKey = pixKey; }

    public String getCnpj() { return cnpj; }
    public void setCnpj(String cnpj) { this.cnpj = cnpj; }

    public StatusOrganizador getStatus() { return status; }
    public void setStatus(StatusOrganizador status) { this.status = status; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Excursao> getExcursoes() { return excursoes; }
    public void setExcursoes(List<Excursao> excursoes) { this.excursoes = excursoes; }
}

//src/main/java/br/com/tourapp/entity/Excursao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusExcursao;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "excursoes")
public class Excursao extends BaseEntity {

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 200, message = "Título deve ter entre 5 e 200 caracteres")
    @Column(nullable = false, length = 200)
    private String titulo;

    @NotBlank(message = "Descrição é obrigatória")
    @Size(min = 10, max = 2000, message = "Descrição deve ter entre 10 e 2000 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String descricao;

    @NotNull(message = "Data de saída é obrigatória")
    @Future(message = "Data de saída deve ser no futuro")
    @Column(name = "data_saida", nullable = false)
    private LocalDateTime dataSaida;

    @Column(name = "data_retorno")
    private LocalDateTime dataRetorno;

    @NotNull(message = "Preço é obrigatório")
    @DecimalMin(value = "0.01", message = "Preço deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal preco;

    @NotNull(message = "Total de vagas é obrigatório")
    @Min(value = 1, message = "Deve ter pelo menos 1 vaga")
    @Column(name = "vagas_total", nullable = false)
    private Integer vagasTotal;

    @Column(name = "vagas_ocupadas", nullable = false)
    private Integer vagasOcupadas = 0;

    @Column(name = "local_saida", length = 300)
    private String localSaida;

    @Column(name = "local_destino", length = 300)
    private String localDestino;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    @ElementCollection
    @CollectionTable(name = "excursao_imagens", joinColumns = @JoinColumn(name = "excursao_id"))
    @Column(name = "url_imagem")
    private List<String> imagens;

    @Column(name = "aceita_pix", nullable = false)
    private Boolean aceitaPix = true;

    @Column(name = "aceita_cartao", nullable = false)
    private Boolean aceitaCartao = true;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusExcursao status = StatusExcursao.RASCUNHO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @OneToMany(mappedBy = "excursao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Excursao() {}

    public Excursao(String titulo, String descricao, LocalDateTime dataSaida, BigDecimal preco, 
                    Integer vagasTotal, Organizador organizador) {
        this.titulo = titulo;
        this.descricao = descricao;
        this.dataSaida = dataSaida;
        this.preco = preco;
        this.vagasTotal = vagasTotal;
        this.organizador = organizador;
    }

    // Métodos auxiliares
    public Integer getVagasDisponiveis() {
        return vagasTotal - vagasOcupadas;
    }

    public boolean temVagasDisponiveis() {
        return getVagasDisponiveis() > 0;
    }

    public boolean isAtiva() {
        return status == StatusExcursao.ATIVA;
    }


    // Getters e Setters
    public String getTitulo() { return titulo; }
    public void setTitulo(String titulo) { this.titulo = titulo; }

    public String getDescricao() { return descricao; }
    public void setDescricao(String descricao) { this.descricao = descricao; }

    public LocalDateTime getDataSaida() { return dataSaida; }
    public void setDataSaida(LocalDateTime dataSaida) { this.dataSaida = dataSaida; }

    public LocalDateTime getDataRetorno() { return dataRetorno; }
    public void setDataRetorno(LocalDateTime dataRetorno) { this.dataRetorno = dataRetorno; }

    public BigDecimal getPreco() { return preco; }
    public void setPreco(BigDecimal preco) { this.preco = preco; }

    public Integer getVagasTotal() { return vagasTotal; }
    public void setVagasTotal(Integer vagasTotal) { this.vagasTotal = vagasTotal; }

    public Integer getVagasOcupadas() { return vagasOcupadas; }
    public void setVagasOcupadas(Integer vagasOcupadas) { this.vagasOcupadas = vagasOcupadas; }

    public String getLocalSaida() { return localSaida; }
    public void setLocalSaida(String localSaida) { this.localSaida = localSaida; }

    public String getLocalDestino() { return localDestino; }
    public void setLocalDestino(String localDestino) { this.localDestino = localDestino; }

    public String getObservacoes() { return observacoes; }
    public void setObservacoes(String observacoes) { this.observacoes = observacoes; }

    public List<String> getImagens() { return imagens; }
    public void setImagens(List<String> imagens) { this.imagens = imagens; }

    public Boolean getAceitaPix() { return aceitaPix; }
    public void setAceitaPix(Boolean aceitaPix) { this.aceitaPix = aceitaPix; }

    public Boolean getAceitaCartao() { return aceitaCartao; }
    public void setAceitaCartao(Boolean aceitaCartao) { this.aceitaCartao = aceitaCartao; }

    public StatusExcursao getStatus() { return status; }
    public void setStatus(StatusExcursao status) { this.status = status; }

    public Organizador getOrganizador() { return organizador; }
    public void setOrganizador(Organizador organizador) { this.organizador = organizador; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Inscricao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusPagamento;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.util.List;

@Entity
@Table(name = "inscricoes")
public class Inscricao extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "excursao_id", nullable = false)
    private Excursao excursao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cliente_id", nullable = false)
    private Cliente cliente;

    @NotNull(message = "Valor pago é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor deve ser maior que zero")
    @Column(name = "valor_pago", nullable = false, precision = 10, scale = 2)
    private BigDecimal valorPago;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_pagamento", nullable = false)
    private StatusPagamento statusPagamento = StatusPagamento.PENDENTE;

    @Column(name = "observacoes_cliente", columnDefinition = "TEXT")
    private String observacoesCliente;

    @OneToMany(mappedBy = "inscricao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Pagamento> pagamentos;

    // Construtores
    public Inscricao() {}

    public Inscricao(Excursao excursao, Cliente cliente, BigDecimal valorPago) {
        this.excursao = excursao;
        this.cliente = cliente;
        this.valorPago = valorPago;
    }

    // Getters e Setters
    public Excursao getExcursao() { return excursao; }
    public void setExcursao(Excursao excursao) { this.excursao = excursao; }

    public Cliente getCliente() { return cliente; }
    public void setCliente(Cliente cliente) { this.cliente = cliente; }

    public BigDecimal getValorPago() { return valorPago; }
    public void setValorPago(BigDecimal valorPago) { this.valorPago = valorPago; }

    public StatusPagamento getStatusPagamento() { return statusPagamento; }
    public void setStatusPagamento(StatusPagamento statusPagamento) { this.statusPagamento = statusPagamento; }

    public String getObservacoesCliente() { return observacoesCliente; }
    public void setObservacoesCliente(String observacoesCliente) { this.observacoesCliente = observacoesCliente; }

    public List<Pagamento> getPagamentos() { return pagamentos; }
    public void setPagamentos(List<Pagamento> pagamentos) { this.pagamentos = pagamentos; }
}

//src/main/java/br/com/tourapp/entity/Pagamento.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.MetodoPagamento;
import br.com.tourapp.enums.StatusPagamento;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "pagamentos")
public class Pagamento extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inscricao_id", nullable = false)
    private Inscricao inscricao;

    @NotNull(message = "Valor é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal valor;

    @Enumerated(EnumType.STRING)
    @Column(name = "metodo_pagamento", nullable = false)
    private MetodoPagamento metodoPagamento;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPagamento status = StatusPagamento.PENDENTE;

    @Column(name = "mercadopago_payment_id")
    private String mercadoPagoPaymentId;

    @Column(name = "mercadopago_preference_id")
    private String mercadoPagoPreferenceId;

    @Column(name = "qr_code")
    private String qrCode;

    @Column(name = "qr_code_base64", columnDefinition = "TEXT")
    private String qrCodeBase64;

    @Column(name = "data_processamento")
    private LocalDateTime dataProcessamento;

    @Column(name = "data_vencimento")
    private LocalDateTime dataVencimento;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    // Construtores
    public Pagamento() {}

    public Pagamento(Inscricao inscricao, BigDecimal valor, MetodoPagamento metodoPagamento) {
        this.inscricao = inscricao;
        this.valor = valor;
        this.metodoPagamento = metodoPagamento;
    }

    // Getters e Setters
    public Inscricao getInscricao() { return inscricao; }
    public void setInscricao(Inscricao inscricao) { this.inscricao = inscricao; }

    public BigDecimal getValor() { return valor; }
    public void setValor(BigDecimal valor) { this.valor = valor; }

    public MetodoPagamento getMetodoPagamento() { return metodoPagamento; }
    public void setMetodoPagamento(MetodoPagamento metodoPagamento) { this.metodoPagamento = metodoPagamento; }

    public StatusPagamento getStatus() { return status; }
    public void setStatus(StatusPagamento status) { this.status = status; }

    public String getMercadoPagoPaymentId() { return mercadoPagoPaymentId; }
    public void setMercadoPagoPaymentId(String mercadoPagoPaymentId) { this.mercadoPagoPaymentId = mercadoPagoPaymentId; }

    public String getMercadoPagoPreferenceId() { return mercadoPagoPreferenceId; }
    public void setMercadoPagoPreferenceId(String mercadoPagoPreferenceId) { this.mercadoPagoPreferenceId = mercadoPagoPreferenceId; }

    public String getQrCode() { return qrCode; }
    public void setQrCode(String qrCode) { this.qrCode = qrCode; }

    public String getQrCodeBase64() { return qrCodeBase64; }
    public void setQrCodeBase64(String qrCodeBase64) { this.qrCodeBase64 = qrCodeBase64; }

    public LocalDateTime getDataProcessamento() { return dataProcessamento; }
    public void setDataProcessamento(LocalDateTime dataProcessamento) { this.dataProcessamento = dataProcessamento; }

    public LocalDateTime getDataVencimento() { return dataVencimento; }
    public void setDataVencimento(LocalDateTime dataVencimento) { this.dataVencimento = dataVencimento; }

    public String getObservacoes() { return observacoes; }
    public void setObservacoes(String observacoes) { this.observacoes = observacoes; }
}

//src/main/java/br/com/tourapp/entity/Notificacao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoNotificacao;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "notificacoes")
public class Notificacao extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "excursao_id")
    private Excursao excursao;

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 100, message = "Título deve ter entre 5 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String titulo;

    @NotBlank(message = "Mensagem é obrigatória")
    @Size(min = 10, max = 500, message = "Mensagem deve ter entre 10 e 500 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String mensagem;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TipoNotificacao tipo = TipoNotificacao.INFO;

    @Column(name = "enviada_em")
    private LocalDateTime enviadaEm;

    @ElementCollection
    @CollectionTable(name = "notificacao_clientes", joinColumns = @JoinColumn(name = "notificacao_id"))
    @Column(name = "cliente_id")
    private List<UUID> clientesAlvo;

    @Column(name = "enviar_para_todos", nullable = false)
    private Boolean enviarParaTodos = false;

    @Column(name = "enviada", nullable = false)
    private Boolean enviada = false;

    // Construtores
    public Notificacao() {}

    public Notificacao(Organizador organizador, String titulo, String mensagem, TipoNotificacao tipo) {
        this.organizador = organizador;
        this.titulo = titulo;
        this.mensagem = mensagem;
        this.tipo = tipo;
    }

    // Getters e Setters
    public Organizador getOrganizador() { return organizador; }
    public void setOrganizador(Organizador organizador) { this.organizador = organizador; }

    public Excursao getExcursao() { return excursao; }
    public void setExcursao(Excursao excursao) { this.excursao = excursao; }

    public String getTitulo() { return titulo; }
    public void setTitulo(String titulo) { this.titulo = titulo; }

    public String getMensagem() { return mensagem; }
    public void setMensagem(String mensagem) { this.mensagem = mensagem; }

    public TipoNotificacao getTipo() { return tipo; }
    public void setTipo(TipoNotificacao tipo) { this.tipo = tipo; }

    public LocalDateTime getEnviadaEm() { return enviadaEm; }
    public void setEnviadaEm(LocalDateTime enviadaEm) { this.enviadaEm = enviadaEm; }

    public List<UUID> getClientesAlvo() { return clientesAlvo; }
    public void setClientesAlvo(List<UUID> clientesAlvo) { this.clientesAlvo = clientesAlvo; }

    public Boolean getEnviarParaTodos() { return enviarParaTodos; }
    public void setEnviarParaTodos(Boolean enviarParaTodos) { this.enviarParaTodos = enviarParaTodos; }

    public Boolean getEnviada() { return enviada; }
    public void setEnviada(Boolean enviada) { this.enviada = enviada; }
}

//src/main/java/br/com/tourapp/config/SecurityConfig.java
package br.com.tourapp.config;

import br.com.tourapp.security.JwtAuthenticationFilter;
import br.com.tourapp.security.CustomUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(CustomUserDetailsService userDetailsService, 
                         JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // Endpoints públicos
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/webhook/**").permitAll()
                .requestMatchers("/health", "/actuator/health").permitAll()
                
                // Endpoints de organizador
                .requestMatchers("/organizador/**").hasRole("ORGANIZADOR")
                
                // Endpoints de cliente
                .requestMatchers("/cliente/**").hasRole("CLIENTE")
                
                // Endpoints administrativos (futuro)
                .requestMatchers("/admin/**").hasRole("ADMIN")
                
                // Todos os outros endpoints requerem autenticação
                .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

//src/main/java/br/com/tourapp/security/JwtUtil.java
package br.com.tourapp.security;

import br.com.tourapp.enums.TipoUsuario;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.expiration}")
    private int jwtExpiration;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUserId(String token) {
        return extractClaim(token, claims -> claims.get("userId", String.class));
    }

    public TipoUsuario extractTipoUsuario(String token) {
        String tipo = extractClaim(token, claims -> claims.get("tipoUsuario", String.class));
        return TipoUsuario.valueOf(tipo);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails, UUID userId, TipoUsuario tipoUsuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("tipoUsuario", tipoUsuario.name());
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSigningKey())
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}

//src/main/java/br/com/tourapp/security/JwtAuthenticationFilter.java
package br.com.tourapp.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request,
                                    @NonNull HttpServletResponse response,
                                    @NonNull FilterChain filterChain) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        userEmail = jwtUtil.extractUsername(jwt);

        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);

            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}

//src/main/java/br/com/tourapp/security/CustomUserDetailsService.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.repository.ClienteRepository;
import br.com.tourapp.repository.OrganizadorRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final ClienteRepository clienteRepository;
    private final OrganizadorRepository organizadorRepository;

    public CustomUserDetailsService(ClienteRepository clienteRepository, 
                                   OrganizadorRepository organizadorRepository) {
        this.clienteRepository = clienteRepository;
        this.organizadorRepository = organizadorRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // Primeiro tenta encontrar cliente
        Cliente cliente = clienteRepository.findByEmail(email).orElse(null);
        if (cliente != null) {
            return new SecurityUser(cliente);
        }

        // Se não encontrou cliente, tenta organizador
        Organizador organizador = organizadorRepository.findByEmail(email).orElse(null);
        if (organizador != null) {
            return new SecurityUser(organizador);
        }

        throw new UsernameNotFoundException("Usuário não encontrado com email: " + email);
    }
}

//src/main/java/br/com/tourapp/security/SecurityUser.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.TipoUsuario;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.UUID;

public class SecurityUser implements UserDetails {

    private final UUID id;
    private final String email;
    private final String senha;
    private final String nome;
    private final TipoUsuario tipoUsuario;
    private final boolean ativo;

    public SecurityUser(Cliente cliente) {
        this.id = cliente.getId();
        this.email = cliente.getEmail();
        this.senha = cliente.getSenha();
        this.nome = cliente.getNome();
        this.tipoUsuario = cliente.getTipoUsuario();
        this.ativo = cliente.getAtivo();
    }

    public SecurityUser(Organizador organizador) {
        this.id = organizador.getId();
        this.email = organizador.getEmail();
        this.senha = organizador.getSenha();
        this.nome = organizador.getNomeEmpresa();
        this.tipoUsuario = organizador.getTipoUsuario();
        this.ativo = organizador.getStatus().name().equals("ATIVO");
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + tipoUsuario.name()));
    }

    @Override
    public String getPassword() {
        return senha;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return ativo;
    }

    // Getters adicionais
    public UUID getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    public String getNome() {
        return nome;
    }

    public TipoUsuario getTipoUsuario() {
        return tipoUsuario;
    }
}

//src/main/java/br/com/tourapp/repository/ClienteRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, UUID> {
    
    Optional<Cliente> findByEmail(String email);
    
    boolean existsByEmail(String email);
}

//src/main/java/br/com/tourapp/repository/OrganizadorRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.StatusOrganizador;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface OrganizadorRepository extends JpaRepository<Organizador, UUID> {
    
    Optional<Organizador> findByEmail(String email);
    
    boolean existsByEmail(String email);
    
    List<Organizador> findByStatus(StatusOrganizador status);
}

//src/main/java/br/com/tourapp/repository/ExcursaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Excursao;
import br.com.tourapp.enums.StatusExcursao;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ExcursaoRepository extends JpaRepository<Excursao, UUID> {
    
    Page<Excursao> findByOrganizadorId(UUID organizadorId, Pageable pageable);
    
    Page<Excursao> findByOrganizadorIdAndStatus(UUID organizadorId, StatusExcursao status, Pageable pageable);
    
    Optional<Excursao> findByIdAndOrganizadorId(UUID id, UUID organizadorId);
    
    List<Excursao> findByStatus(StatusExcursao status);
    
    @Query("SELECT e FROM Excursao e WHERE e.status = :status AND e.dataSaida BETWEEN :inicio AND :fim")
    List<Excursao> findByStatusAndDataSaidaBetween(@Param("status") StatusExcursao status, 
                                                   @Param("inicio") LocalDateTime inicio, 
                                                   @Param("fim") LocalDateTime fim);
}

//src/main/java/br/com/tourapp/repository/InscricaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Inscricao;
import br.com.tourapp.enums.StatusPagamento;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.//pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.3</version>
        <relativePath/>
    </parent>
    
    <groupId>br.com.tourapp</groupId>
    <artifactId>tourapp-backend</artifactId>
    <version>1.0.0</version>
    <name>TourApp Backend</name>
    <description>Sistema de gerenciamento de excursões</description>
    
    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.6</version>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Mercado Pago SDK -->
        <dependency>
            <groupId>com.mercadopago</groupId>
            <artifactId>sdk-java</artifactId>
            <version>2.1.29</version>
        </dependency>
        
        <!-- Cloudinary -->
        <dependency>
            <groupId>com.cloudinary</groupId>
            <artifactId>cloudinary-http45</artifactId>
            <version>2.5.1</version>
        </dependency>
        
        <!-- Firebase Admin -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.4.1</version>
        </dependency>
        
        <!-- Utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>3.2.1</version>
        </dependency>
        
        <!-- Micrometer para métricas -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>
        
        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <configuration>
                    <url>${DB_URL}</url>
                    <user>${DB_USER}</user>
                    <password>${DB_PASSWORD}</password>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

//src/main/resources/application.yml
spring:
  application:
    name: tourapp
  
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  
  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/tourapp}
    username: ${DB_USER:tourapp}
    password: ${DB_PASSWORD:tourapp123}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      connection-timeout: 20000
      validation-timeout: 5000
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
        use_sql_comments: true
    defer-datasource-initialization: false
  
  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration
    validate-on-migrate: true
  
  mail:
    host: ${MAIL_HOST:smtp.gmail.com}
    port: ${MAIL_PORT:587}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
  
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  
  # Virtual Threads (JDK 21 feature)
  threads:
    virtual:
      enabled: true

server:
  port: ${PORT:8080}
  servlet:
    context-path: /api
  # Habilitar HTTP/2 e compressão
  http2:
    enabled: true
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css
  error:
    include-stacktrace: never
    include-exception: false

# Configurações customizadas
app:
  jwt:
    secret: ${JWT_SECRET:tourapp-super-secret-key-change-in-production}
    expiration: ${JWT_EXPIRATION:86400000} # 24 horas em ms
  
  cors:
    allowed-origins: ${CORS_ORIGINS:http://localhost:3000,https://tourapp.vercel.app}
    allowed-methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
    allowed-headers: "*"
    allow-credentials: true
  
  mercadopago:
    access-token: ${MERCADOPAGO_ACCESS_TOKEN:}
    public-key: ${MERCADOPAGO_PUBLIC_KEY:}
    webhook-secret: ${MERCADOPAGO_WEBHOOK_SECRET:}
    sandbox: ${MERCADOPAGO_SANDBOX:true}
  
  cloudinary:
    cloud-name: ${CLOUDINARY_CLOUD_NAME:}
    api-key: ${CLOUDINARY_API_KEY:}
    api-secret: ${CLOUDINARY_API_SECRET:}
    secure: true
  
  firebase:
    service-account-path: ${FIREBASE_SERVICE_ACCOUNT_PATH:classpath:firebase-service-account.json}
  
  frontend:
    base-url: ${FRONTEND_BASE_URL:http://localhost:3000}
  
  file:
    upload-dir: ${UPLOAD_DIR:./uploads}
  
  cache:
    enabled: ${CACHE_ENABLED:true}
    ttl: ${CACHE_TTL:3600} # 1 hora

# Logging com melhor performance
logging:
  level:
    br.com.tourapp: ${LOG_LEVEL:INFO}
    org.springframework.security: ${SECURITY_LOG_LEVEL:WARN}
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: ${SQL_PARAMS_LOG_LEVEL:WARN}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: ${LOG_FILE:logs/tourapp.log}

# Management endpoints com security
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when_authorized
      show-components: when_authorized
    metrics:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

//src/main/java/br/com/tourapp/TourappApplication.java
package br.com.tourapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaAuditing
@EnableAsync
@EnableScheduling
public class TourappApplication {

    public static void main(String[] args) {
        SpringApplication.run(TourappApplication.class, args);
    }
}

//src/main/java/br/com/tourapp/entity/BaseEntity.java
package br.com.tourapp.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    // Getters e Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Long getVersion() {
        return version;
    }

    public void setVersion(Long version) {
        this.version = version;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BaseEntity)) return false;
        BaseEntity that = (BaseEntity) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}

//src/main/java/br/com/tourapp/enums/StatusOrganizador.java
package br.com.tourapp.enums;

public enum StatusOrganizador {
    PENDENTE("Pendente de aprovação"),
    ATIVO("Ativo"),
    INATIVO("Inativo"),
    SUSPENSO("Suspenso");

    private final String descricao;

    StatusOrganizador(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusExcursao.java
package br.com.tourapp.enums;

public enum StatusExcursao {
    RASCUNHO("Rascunho"),
    ATIVA("Ativa"),
    LOTADA("Lotada"),
    CANCELADA("Cancelada"),
    FINALIZADA("Finalizada");

    private final String descricao;

    StatusExcursao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusPagamento.java
package br.com.tourapp.enums;

public enum StatusPagamento {
    PENDENTE("Pendente"),
    PROCESSANDO("Processando"),
    APROVADO("Aprovado"),
    REJEITADO("Rejeitado"),
    CANCELADO("Cancelado"),
    REEMBOLSADO("Reembolsado"),
    EXPIRADO("Expirado");

    private final String descricao;

    StatusPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/MetodoPagamento.java
package br.com.tourapp.enums;

public enum MetodoPagamento {
    PIX("PIX"),
    CARTAO_CREDITO("Cartão de Crédito"),
    CARTAO_DEBITO("Cartão de Débito"),
    BOLETO("Boleto"),
    DINHEIRO("Dinheiro");

    private final String descricao;

    MetodoPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoNotificacao.java
package br.com.tourapp.enums;

public enum TipoNotificacao {
    INFO("Informação"),
    PROMOCAO("Promoção"),
    LEMBRETE("Lembrete"),
    URGENTE("Urgente"),
    CONFIRMACAO("Confirmação"),
    CANCELAMENTO("Cancelamento");

    private final String descricao;

    TipoNotificacao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoUsuario.java
package br.com.tourapp.enums;

public enum TipoUsuario {
    CLIENTE("Cliente"),
    ORGANIZADOR("Organizador"),
    ADMIN("Administrador");

    private final String descricao;

    TipoUsuario(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/entity/Cliente.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "clientes")
public class Cliente extends BaseEntity {

    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String nome;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "push_token")
    private String pushToken;

    @Column(name = "email_notifications", nullable = false)
    private Boolean emailNotifications = true;

    @Column(name = "sms_notifications", nullable = false)
    private Boolean smsNotifications = true;

    @Column(name = "ativo", nullable = false)
    private Boolean ativo = true;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.CLIENTE;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Cliente() {}

    public Cliente(String nome, String email, String senha) {
        this.nome = nome;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPushToken() { return pushToken; }
    public void setPushToken(String pushToken) { this.pushToken = pushToken; }

    public Boolean getEmailNotifications() { return emailNotifications; }
    public void setEmailNotifications(Boolean emailNotifications) { this.emailNotifications = emailNotifications; }

    public Boolean getSmsNotifications() { return smsNotifications; }
    public void setSmsNotifications(Boolean smsNotifications) { this.smsNotifications = smsNotifications; }

    public Boolean getAtivo() { return ativo; }
    public void setAtivo(Boolean ativo) { this.ativo = ativo; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Organizador.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusOrganizador;
import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "organizadores")
public class Organizador extends BaseEntity {

    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 150, message = "Nome da empresa deve ter entre 2 e 150 caracteres")
    @Column(name = "nome_empresa", nullable = false, length = 150)
    private String nomeEmpresa;

    @NotBlank(message = "Nome do responsável é obrigatório")
    @Size(min = 2, max = 100, message = "Nome do responsável deve ter entre 2 e 100 caracteres")
    @Column(name = "nome_responsavel", nullable = false, length = 100)
    private String nomeResponsavel;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "pix_key", length = 100)
    private String pixKey;

    @Size(max = 18, message = "CNPJ deve ter no máximo 18 caracteres")
    @Column(length = 18)
    private String cnpj;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusOrganizador status = StatusOrganizador.PENDENTE;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.ORGANIZADOR;

    @OneToMany(mappedBy = "organizador", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Excursao> excursoes;

    // Construtores
    public Organizador() {}

    public Organizador(String nomeEmpresa, String nomeResponsavel, String email, String senha) {
        this.nomeEmpresa = nomeEmpresa;
        this.nomeResponsavel = nomeResponsavel;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNomeEmpresa() { return nomeEmpresa; }
    public void setNomeEmpresa(String nomeEmpresa) { this.nomeEmpresa = nomeEmpresa; }

    public String getNomeResponsavel() { return nomeResponsavel; }
    public void setNomeResponsavel(String nomeResponsavel) { this.nomeResponsavel = nomeResponsavel; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPixKey() { return pixKey; }
    public void setPixKey(String pixKey) { this.pixKey = pixKey; }

    public String getCnpj() { return cnpj; }
    public void setCnpj(String cnpj) { this.cnpj = cnpj; }

    public StatusOrganizador getStatus() { return status; }
    public void setStatus(StatusOrganizador status) { this.status = status; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Excursao> getExcursoes() { return excursoes; }
    public void setExcursoes(List<Excursao> excursoes) { this.excursoes = excursoes; }
}

//src/main/java/br/com/tourapp/entity/Excursao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusExcursao;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "excursoes")
public class Excursao extends BaseEntity {

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 200, message = "Título deve ter entre 5 e 200 caracteres")
    @Column(nullable = false, length = 200)
    private String titulo;

    @NotBlank(message = "Descrição é obrigatória")
    @Size(min = 10, max = 2000, message = "Descrição deve ter entre 10 e 2000 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String descricao;

    @NotNull(message = "Data de saída é obrigatória")
    @Future(message = "Data de saída deve ser no futuro")
    @Column(name = "data_saida", nullable = false)
    private LocalDateTime dataSaida;

    @Column(name = "data_retorno")
    private LocalDateTime dataRetorno;

    @NotNull(message = "Preço é obrigatório")
    @DecimalMin(value = "0.01", message = "Preço deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal preco;

    @NotNull(message = "Total de vagas é obrigatório")
    @Min(value = 1, message = "Deve ter pelo menos 1 vaga")
    @Column(name = "vagas_total", nullable = false)
    private Integer vagasTotal;

    @Column(name = "vagas_ocupadas", nullable = false)
    private Integer vagasOcupadas = 0;

    @Column(name = "local_saida", length = 300)
    private String localSaida;

    @Column(name = "local_destino", length = 300)
    private String localDestino;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    @ElementCollection
    @CollectionTable(name = "excursao_imagens", joinColumns = @JoinColumn(name = "excursao_id"))
    @Column(name = "url_imagem")
    private List<String> imagens;

    @Column(name = "aceita_pix", nullable = false)
    private Boolean aceitaPix = true;

    @Column(name = "aceita_cartao", nullable = false)
    private Boolean aceitaCartao = true;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusExcursao status = StatusExcursao.RASCUNHO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @OneToMany(mappedBy = "excursao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Excursao() {}

    public Excursao(String titulo, String descricao, LocalDateTime dataSaida, BigDecimal preco, 
                    Integer vagasTotal, Organizador organizador) {
        this.titulo = titulo;
        this.descricao = descricao;
        this.dataSaida = dataSaida;
        this.preco = preco;
        this.vagasTotal = vagasTotal;
        this.organizador = organizador;
    }

    // Métodos auxiliares
    public Integer getVagasDisponiveis() {
        return vagasTotal - vagasOcupadas;
    }

    public boolean temVagasDisponiveis() {
        return getVagasDisponiveis() > 0;
    }

    public boolean isAtiva() {
        return status == StatusExcursao.ATIVA;
    }

    import java.util.Optional;
import java.util.UUID;

@Repository
public interface InscricaoRepository extends JpaRepository<Inscricao, UUID> {
    
    Page<Inscricao> findByClienteId(UUID clienteId, Pageable pageable);
    
    Page<Inscricao> findByExcursaoId(UUID excursaoId, Pageable pageable);
    
    @Query("SELECT i FROM Inscricao i WHERE i.excursao.organizador.id = :organizadorId")
    Page<Inscricao> findByOrganizadorId(@Param("organizadorId") UUID organizadorId, Pageable pageable);
    
    @Query("SELECT i FROM Inscricao i WHERE i.excursao.organizador.id = :organizadorId AND i.excursao.id = :excursaoId")
    Page<Inscricao> findByOrganizadorIdAndExcursaoId(@Param("organizadorId") UUID organizadorId, 
                                                     @Param("excursaoId") UUID excursaoId, Pageable pageable);
    
    Optional<Inscricao> findByIdAndClienteId(UUID id, UUID clienteId);
    
    boolean existsByClienteIdAndExcursaoId(UUID clienteId, UUID excursaoId);
    
    List<Inscricao> findByStatusPagamento(StatusPagamento status);
    
    long countByExcursaoId(UUID excursaoId);
}

//src/main/java/br/com/tourapp/repository/PagamentoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Pagamento;
import br.com.tourapp.enums.StatusPagamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface PagamentoRepository extends JpaRepository<Pagamento, UUID> {
    
    List<Pagamento> findByInscricaoId(UUID inscricaoId);
    
    Optional<Pagamento> findByMercadoPagoPaymentId(String mercadoPagoPaymentId);
    
    List<Pagamento> findByStatus(StatusPagamento status);
}

//src/main/java/br/com/tourapp/repository/NotificacaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Notificacao;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface NotificacaoRepository extends JpaRepository<Notificacao, UUID> {
    
    Page<Notificacao> findByOrganizadorId(UUID organizadorId, Pageable pageable);
    
    List<Notificacao> findByEnviadaFalse();
}

//src/main/java/br/com/tourapp/service/AuthService.java
package br.com.tourapp.service;

import br.com.tourapp.dto.request.CadastroClienteRequest;
import br.com.tourapp.dto.request.CadastroOrganizadorRequest;
import br.com.tourapp.dto.request.LoginRequest;
import br.com.tourapp.dto.response.AuthResponse;
import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.StatusOrganizador;
import br.com.tourapp.enums.TipoUsuario;
import br.com.tourapp.exception.BusinessException;
import br.com.tourapp.exception.UnauthorizedException;
import br.com.tourapp.repository.ClienteRepository;
import br.com.tourapp.repository.OrganizadorRepository;
import br.com.tourapp.security.JwtUtil;
import br.com.tourapp.security.SecurityUser;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class AuthService {

    private final ClienteRepository clienteRepository;
    private final OrganizadorRepository organizadorRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    public AuthService(ClienteRepository clienteRepository,
                      OrganizadorRepository organizadorRepository,
                      PasswordEncoder passwordEncoder,
                      JwtUtil jwtUtil,
                      AuthenticationManager authenticationManager) {
        this.clienteRepository = clienteRepository;
        this.organizadorRepository = organizadorRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
    }

    public AuthResponse login(LoginRequest request) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getEmail(), request.getSenha())
            );

            SecurityUser user = (SecurityUser) authentication.getPrincipal();
            String token = jwtUtil.generateToken(user, user.getId(), user.getTipoUsuario());

            return new AuthResponse(
                token,
                user.getTipoUsuario(),
                user.getId(),
                user.getNome(),
                user.getEmail()
            );

        } catch (Exception e) {
            throw new UnauthorizedException("Email ou senha inválidos");
        }
    }

    public AuthResponse cadastrarCliente(CadastroClienteRequest request) {
        // Verificar se o email já existe
        if (clienteRepository.existsByEmail(request.getEmail()) || 
            organizadorRepository.existsByEmail(request.getEmail())) {
            throw new BusinessException("Email já está em uso");
        }

        // Criar novo cliente
        Cliente cliente = new Cliente();
        cliente.setNome(request.getNome());
        cliente.setEmail(request.getEmail());
        cliente.setSenha(passwordEncoder.encode(request.getSenha()));
        cliente.setTelefone(request.getTelefone());

        cliente = clienteRepository.save(cliente);

        // Gerar token
        SecurityUser user = new SecurityUser(cliente);
        String token = jwtUtil.generateToken(user, cliente.getId(), TipoUsuario.CLIENTE);

        return new AuthResponse(
            token,
            TipoUsuario.CLIENTE,
            cliente.getId(),
            cliente.getNome(),
            cliente.getEmail()
        );
    }

    public AuthResponse cadastrarOrganizador(CadastroOrganizadorRequest request) {
        // Verificar se o email já existe
        if (clienteRepository.existsByEmail(request.getEmail()) || 
            organizadorRepository.existsByEmail(request.getEmail())) {
            throw new BusinessException("Email já está em uso");
        }

        // Criar novo organizador
        Organizador organizador = new Organizador();
        organizador.setNomeEmpresa(request.getNomeEmpresa());
        organizador.setNomeResponsavel(request.getNomeResponsavel());
        organizador.setEmail(request.getEmail());
        organizador.setSenha(passwordEncoder.encode(request.getSenha()));
        organizador.setTelefone(request.getTelefone());
        organizador.setPixKey(request.getPixKey());
        organizador.setCnpj(request.getCnpj());
        organizador.setStatus(StatusOrganizador.ATIVO); // Para MVP, aprovar automaticamente

        organizador = organizadorRepository.save(organizador);

        // Gerar token
        SecurityUser user = new SecurityUser(organizador);
        String token = jwtUtil.generateToken(user, organizador.getId(), TipoUsuario.ORGANIZADOR);

        return new AuthResponse(
            token,
            TipoUsuario.ORGANIZADOR,
            organizador.getId(),
            organizador.getNomeEmpresa(),
            organizador.getEmail()
        );
    }

    public AuthResponse refreshToken(String bearerToken) {
        String token = bearerToken.replace("Bearer ", "");
        
        if (!jwtUtil.validateToken(token)) {
            throw new UnauthorizedException("Token inválido");
        }

        String email = jwtUtil.extractUsername(token);
        TipoUsuario tipoUsuario = jwtUtil.extractTipoUsuario(token);

        SecurityUser user;
        String nome;

        if (tipoUsuario == TipoUsuario.CLIENTE) {
            Cliente cliente = clienteRepository.findByEmail(email)
                .orElseThrow(() -> new UnauthorizedException("Usuário não encontrado"));
            user = new SecurityUser(cliente);
            nome = cliente.getNome();
        } else {
            Organizador organizador = organizadorRepository.findByEmail(email)
                .orElseThrow(() -> new UnauthorizedException("Usuário não encontrado"));
            user = new SecurityUser(organizador);
            nome = organizador.getNomeEmpresa();
        }

        String newToken = jwtUtil.generateToken(user, user.getId(), user.getTipoUsuario());

        return new AuthResponse(
            newToken,
            user.getTipoUsuario(),
            user.getId(),
            nome,
            user.getEmail()
        );
    }
}

//src/main/java/br/com/tourapp/dto/request/LoginRequest.java
package br.com.tourapp.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    
    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    private String email;
    
    @NotBlank(message = "Senha é obrigatória")
    private String senha;

    // Construtores
    public LoginRequest() {}

    public LoginRequest(String email, String senha) {
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }
}

//src/main/java/br/com/tourapp/dto/request/CadastroClienteRequest.java
package br.com.tourapp.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class CadastroClienteRequest {
    
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    private String nome;
    
    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    private String email;
    
    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    private String senha;
    
    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    private String telefone;

    // Construtores
    public CadastroClienteRequest() {}

    // Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
}

//src/main/java/br/com/tourapp/dto/request/CadastroOrganizadorRequest.java
package br.com.tourapp.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class CadastroOrganizadorRequest {
    
    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 150, message = "Nome da empresa deve ter entre 2 e 150 caracteres")
    private String nomeEmpresa;
    
    @NotBlank(message = "Nome do responsável é obrigatório")
    @Size(min = 2, max = 100, message = "Nome do responsável deve ter entre 2 e 100 caracteres")
    private String nomeResponsavel;
    
    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    private String email;
    
    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    private String senha;
    
    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    private String telefone;
    
    @Size(max = 100, message = "Chave PIX deve ter no máximo 100 caracteres")
    private String pixKey;
    
    @Size(max = 18, message = "CNPJ deve ter no máximo 18 caracteres")
    private String cnpj;

    // Construtores
    public CadastroOrganizadorRequest() {}

    // Getters e Setters
    public String getNomeEmpresa() { return nomeEmpresa; }
    public void setNomeEmpresa(String nomeEmpresa) { this.nomeEmpresa = nomeEmpresa; }

    public String getNomeResponsavel() { return nomeResponsavel; }
    public void setNomeResponsavel(String nomeResponsavel) { this.nomeResponsavel = nomeResponsavel; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPixKey() { return pixKey; }
    public void setPixKey(String pixKey) { this.pixKey = pixKey; }

    public String getCnpj() { return cnpj; }
    public void setCnpj(String cnpj) { this.cnpj = cnpj; }
}

//src/main/java/br/com/tourapp/dto/response/AuthResponse.java
package br.com.tourapp.dto.response;

import br.com.tourapp.enums.TipoUsuario;

import java.util.UUID;

public class AuthResponse {
    
    private String token;
    private TipoUsuario tipoUsuario;
    private UUID userId;
    private String nome;
    private String email;

    // Construtores
    public AuthResponse() {}

    public AuthResponse(String token, TipoUsuario tipoUsuario, UUID userId, String nome, String email) {
        this.token = token;
        this.tipoUsuario = tipoUsuario;
        this.userId = userId;
        this.nome = nome;
        this.email = email;
    }

    // Getters e Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public UUID getUserId() { return userId; }
    public void setUserId(UUID userId) { this.userId = userId; }

    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

//src/main/java/br/com/tourapp/controller/AuthController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.CadastroClienteRequest;
import br.com.tourapp.dto.request.CadastroOrganizadorRequest;
import br.com.tourapp.dto.request.LoginRequest;
import br.com.tourapp.dto.response.AuthResponse;
import br.com.tourapp.service.AuthService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest request) {
        AuthResponse response = authService.login(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cadastro/cliente")
    public ResponseEntity<AuthResponse> cadastroCliente(@Valid @RequestBody CadastroClienteRequest request) {
        AuthResponse response = authService.cadastrarCliente(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cadastro/organizador")
    public ResponseEntity<AuthResponse> cadastroOrganizador(@Valid @RequestBody CadastroOrganizadorRequest request) {
        AuthResponse response = authService.cadastrarOrganizador(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthResponse> refresh(@RequestHeader("Authorization") String token) {
        AuthResponse response = authService.refreshToken(token);
        return ResponseEntity.ok(response);
    }
}

//src/main/java/br/com/tourapp/controller/PublicController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.InscricaoRequest;
import br.com.tourapp.dto.response.ExcursaoResponse;
import br.com.tourapp.dto.response.InscricaoResponse;
import br.com.tourapp.service.ExcursaoService;
import br.com.tourapp.service.InscricaoService;
import br.com.tourapp.security.SecurityUser;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/public")
@CrossOrigin(origins = "*")
public class PublicController {

    private final ExcursaoService excursaoService;
    private final InscricaoService inscricaoService;

    public PublicController(ExcursaoService excursaoService, InscricaoService inscricaoService) {
        this.excursaoService = excursaoService;
        this.inscricaoService = inscricaoService;
    }

    @GetMapping("/excursoes/{id}")
    public ResponseEntity<ExcursaoResponse> obterExcursaoPublica(@PathVariable UUID id) {
        ExcursaoResponse response = excursaoService.obterExcursaoPublica(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/excursoes/{excursaoId}/inscricoes")
    public ResponseEntity<InscricaoResponse> inscreverNaExcursao(
            @PathVariable UUID excursaoId,
            @Valid @RequestBody InscricaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        InscricaoResponse response = inscricaoService.criarInscricao(excursaoId, request, user.getId());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("OK");
    }
}

//src/main/java/br/com/tourapp/exception/GlobalExceptionHandler.java
package br.com.tourapp.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.badRequest().body(error);
    }

    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.notFound().build();
    }

    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.UNAUTHORIZED.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ValidationErrorResponse validationError = new ValidationErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Erro de validação",
            LocalDateTime.now(),
            errors
        );
        return ResponseEntity.badRequest().body(validationError);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Erro interno do servidor",
            LocalDateTime.now()
        );
        return ResponseEntity.internalServerError().body(error);
    }

    // Classes de resposta de erro
    public static class ErrorResponse {
        private int status;
        private String message;
        private LocalDateTime timestamp;

        public ErrorResponse(int status, String message, LocalDateTime timestamp) {
            this.status = status;
            this.message = message;
            this.timestamp = timestamp;
        }

        // Getters e Setters
        public int getStatus() { return status; }
        public void setStatus(int status) { this.status = status; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    }

    public static class ValidationErrorResponse extends ErrorResponse {
        private Map<String, String> errors;

        public ValidationErrorResponse(int status, String message, LocalDateTime timestamp, Map<String, String> errors) {
            super(status, message, timestamp);
            this.errors = errors;
        }

        public Map<String, String> getErrors() { return errors; }
        public void setErrors(Map<String, String> errors) { this.errors = errors; }
    }
}

//src/main/java/br/com/tourapp/exception/BusinessException.java
package br.com.tourapp.exception;

public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }
}

//src/main/java/br/com/tourapp/exception/NotFoundException.java
package br.com.tourapp.exception;

public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}

//src/main/java/br/com/tourapp/exception/UnauthorizedException.java
package br.com.tourapp.exception;

public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}

//src/main/resources/db/migration/V1__create_cliente_table.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE clientes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    senha VARCHAR(255) NOT NULL,
    telefone VARCHAR(20),
    push_token VARCHAR(255),
    email_notifications BOOLEAN NOT NULL DEFAULT true,
    sms_notifications BOOLEAN NOT NULL DEFAULT true,
    ativo BOOLEAN NOT NULL DEFAULT true,
    tipo_usuario VARCHAR(20) NOT NULL DEFAULT 'CLIENTE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0
);

CREATE INDEX idx_clientes_email ON clientes(email);
CREATE INDEX idx_clientes_ativo ON clientes(ativo);

//src/main/resources/db/migration/V2__create_organizador_table.sql
CREATE TABLE organizadores (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome_empresa VARCHAR(150) NOT NULL,
    nome_responsavel VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    senha VARCHAR(255) NOT NULL,
    telefone VARCHAR(20),
    pix_key VARCHAR(100),
    cnpj VARCHAR(18),
    status VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    tipo_usuario VARCHAR(20) NOT NULL DEFAULT 'ORGANIZADOR',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0
);

CREATE INDEX idx_organizadores_email ON organizadores(email);
CREATE INDEX idx_organizadores_status ON organizadores(status);

//src/main/resources/db/migration/V3__create_excursao_table.sql
CREATE TABLE excursoes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organizador_id UUID NOT NULL REFERENCES organizadores(id) ON DELETE CASCADE,
    titulo VARCHAR(200) NOT NULL,
    descricao TEXT NOT NULL,
    data_saida TIMESTAMP NOT NULL,
    data_retorno TIMESTAMP,
    preco DECIMAL(10,2) NOT NULL,
    vagas_total INTEGER NOT NULL,
    vagas_ocupadas INTEGER NOT NULL DEFAULT 0,
    local_saida VARCHAR(300),
    local_destino VARCHAR(300),
    observacoes TEXT,
    aceita_pix BOOLEAN NOT NULL DEFAULT true,
    aceita_cartao BOOLEAN NOT NULL DEFAULT true,
    status VARCHAR(20) NOT NULL DEFAULT 'RASCUNHO',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0,
    
    CONSTRAINT chk_vagas_ocupadas CHECK (vagas_ocupadas >= 0),
    CONSTRAINT chk_vagas_total CHECK (vagas_total > 0),
    CONSTRAINT chk_vagas_ocupadas_menor_total CHECK (vagas_ocupadas <= vagas_total),
    CONSTRAINT chk_preco_positivo CHECK (preco > 0)
);

CREATE INDEX idx_excursoes_organizador ON excursoes(organizador_id);
CREATE INDEX idx_excursoes_status ON excursoes(status);
CREATE INDEX idx_excursoes_data_saida ON excursoes(data_saida);
CREATE INDEX idx_excursoes_ativas ON excursoes(status, data_saida) WHERE status = 'ATIVA';

CREATE TABLE excursao_imagens (
    excursao_id UUID NOT NULL REFERENCES excursoes(id) ON DELETE CASCADE,
    url_imagem VARCHAR(500) NOT NULL,
    PRIMARY KEY (excursao_id, url_imagem)
);

//src/main/resources/db/migration/V4__create_inscricao_table.sql
CREATE TABLE inscricoes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    excursao_id UUID NOT NULL REFERENCES excursoes(id) ON DELETE CASCADE,
    cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
    valor_pago DECIMAL(10,2) NOT NULL,
    status_pagamento VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    observacoes_cliente TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0,
    
    CONSTRAINT chk_valor_pago_positivo CHECK (valor_pago > 0),
    CONSTRAINT uk_inscricao_cliente_excursao UNIQUE (cliente_id, excursao_id)
);

CREATE INDEX idx_inscricoes_excursao ON inscricoes(excursao_id);
CREATE INDEX idx_inscricoes_cliente ON inscricoes(cliente_id);
CREATE INDEX idx_inscricoes_status ON inscricoes(status_pagamento);

//src/main/resources/db/migration/V5__create_pagamento_table.sql
CREATE TABLE pagamentos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    inscricao_id UUID NOT NULL REFERENCES inscricoes(id) ON DELETE CASCADE,
    valor DECIMAL(10,2) NOT NULL,
    metodo_pagamento VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    mercadopago_payment_id VARCHAR(100),
    mercadopago_preference_id VARCHAR(100),
    qr_code VARCHAR(500),
    qr_code_base64 TEXT,
    data_processamento TIMESTAMP,
    data_vencimento TIMESTAMP,
    observacoes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0,
    
    CONSTRAINT chk_valor_positivo CHECK (valor > 0)
);

CREATE INDEX idx_pagamentos_inscricao ON pagamentos(inscricao_id);
CREATE INDEX idx_pagamentos_status ON pagamentos(status);
CREATE INDEX idx_pagamentos_mercadopago ON pagamentos(mercadopago_payment_id);
CREATE INDEX idx_pagamentos_metodo ON pagamentos(metodo_pagamento);

//src/main/resources/db/migration/V6__create_notificacao_table.sql
CREATE TABLE notificacoes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organizador_id UUID NOT NULL REFERENCES organizadores(id) ON DELETE CASCADE,
    excursao_i    // Getters e Setters
    public String getTitulo() { return titulo; }
    public void setTitulo(String titulo) { this.titulo = titulo; }

    public String getDescricao() { return descricao; }
    public void setDescricao(String descricao) { this.descricao = descricao; }

    public LocalDateTime getDataSaida() { return dataSaida; }
    public void setDataSaida(LocalDateTime dataSaida) { this.dataSaida = dataSaida; }

    public LocalDateTime getDataRetorno() { return dataRetorno; }
    public void setDataRetorno(LocalDateTime dataRetorno) { this.dataRetorno = dataRetorno; }

    public BigDecimal getPreco() { return preco; }
    public void setPreco(BigDecimal preco) { this.preco = preco; }

    public Integer getVagasTotal() { return vagasTotal; }
    public void setVagasTotal(Integer vagasTotal) { this.vagasTotal = vagasTotal; }

    public Integer getVagasOcupadas() { return vagasOcupadas; }
    public void setVagasOcupadas(Integer vagasOcupadas) { this.vagasOcupadas = vagasOcupadas; }

    public String getLocalSaida() { return localSaida; }
    public void setLocalSaida(String localSaida) { this.localSaida = localSaida; }

    public String getLocalDestino() { return localDestino; }
    public void setLocalDestino(String localDestino) { this.localDestino = localDestino; }

    public String getObservacoes() { return observacoes; }
    public void setObservacoes(String observacoes) { this.observacoes = observacoes; }

    public List<String> getImagens() { return imagens; }
    public void setImagens(List<String> imagens) { this.imagens = imagens; }

    public Boolean getAceitaPix() { return aceitaPix; }
    public void setAceitaPix(Boolean aceitaPix) { this.aceitaPix = aceitaPix; }

    public Boolean getAceitaCartao() { return aceitaCartao; }
    public void setAceitaCartao(Boolean aceitaCartao) { this.aceitaCartao = aceitaCartao; }

    public StatusExcursao getStatus() { return status; }
    public void setStatus(StatusExcursao status) { this.status = status; }

    public Organizador getOrganizador() { return organizador; }
    public void setOrganizador(Organizador organizador) { this.organizador = organizador; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Inscricao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusPagamento;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.util.List;

@Entity
@Table(name = "inscricoes")
public class Inscricao extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "excursao_id", nullable = false)
    private Excursao excursao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cliente_id", nullable = false)
    private Cliente cliente;

    @NotNull(message = "Valor pago é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor deve ser maior que zero")
    @Column(name = "valor_pago", nullable = false, precision = 10, scale = 2)
    private BigDecimal valorPago;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_pagamento", nullable = false)
    private StatusPagamento statusPagamento = StatusPagamento.PENDENTE;

    @Column(name = "observacoes_cliente", columnDefinition = "TEXT")
    private String observacoesCliente;

    @OneToMany(mappedBy = "inscricao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Pagamento> pagamentos;

    // Construtores
    public Inscricao() {}

    public Inscricao(Excursao excursao, Cliente cliente, BigDecimal valorPago) {
        this.excursao = excursao;
        this.cliente = cliente;
        this.valorPago = valorPago;
    }

    // Getters e Setters
    public Excursao getExcursao() { return excursao; }
    public void setExcursao(Excursao excursao) { this.excursao = excursao; }

    public Cliente getCliente() { return cliente; }
    public void setCliente(Cliente cliente) { this.cliente = cliente; }

    public BigDecimal getValorPago() { return valorPago; }
    public void setValorPago(BigDecimal valorPago) { this.valorPago = valorPago; }

    public StatusPagamento getStatusPagamento() { return statusPagamento; }
    public void setStatusPagamento(StatusPagamento statusPagamento) { this.statusPagamento = statusPagamento; }

    public String getObservacoesCliente() { return observacoesCliente; }
    public void setObservacoesCliente(String observacoesCliente) { this.observacoesCliente = observacoesCliente; }

    public List<Pagamento> getPagamentos() { return pagamentos; }
    public void setPagamentos(List<Pagamento> pagamentos) { this.pagamentos = pagamentos; }
}

//src/main/java/br/com/tourapp/entity/Pagamento.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.MetodoPagamento;
import br.com.tourapp.enums.StatusPagamento;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "pagamentos")
public class Pagamento extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inscricao_id", nullable = false)
    private Inscricao inscricao;

    @NotNull(message = "Valor é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal valor;

    @Enumerated(EnumType.STRING)
    @Column(name = "metodo_pagamento", nullable = false)
    private MetodoPagamento metodoPagamento;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPagamento status = StatusPagamento.PENDENTE;

    @Column(name = "mercadopago_payment_id")
    private String mercadoPagoPaymentId;

    @Column(name = "mercadopago_preference_id")
    private String mercadoPagoPreferenceId;

    @Column(name = "qr_code")
    private String qrCode;

    @Column(name = "qr_code_base64", columnDefinition = "TEXT")
    private String qrCodeBase64;

    @Column(name = "data_processamento")
    private LocalDateTime dataProcessamento;

    @Column(name = "data_vencimento")
    private LocalDateTime dataVencimento;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    // Construtores
    public Pagamento() {}

    public Pagamento(Inscricao inscricao, BigDecimal valor, MetodoPagamento metodoPagamento) {
        this.inscricao = inscricao;
        this.valor = valor;
        this.metodoPagamento = metodoPagamento;
    }

    // Getters e Setters
    public Inscricao getInscricao() { return inscricao; }
    public void setInscricao(Inscricao inscricao) { this.inscricao = inscricao; }

    public BigDecimal getValor() { return valor; }
    public void setValor(BigDecimal valor) { this.valor = valor; }

    public MetodoPagamento getMetodoPagamento() { return metodoPagamento; }
    public void setMetodoPagamento(MetodoPagamento metodoPagamento) { this.metodoPagamento = metodoPagamento; }

    public StatusPagamento getStatus() { return status; }
    public void setStatus(StatusPagamento status) { this.status = status; }

    public String getMercadoPagoPaymentId() { return mercadoPagoPaymentId; }
    public void setMercadoPagoPaymentId(String mercadoPagoPaymentId) { this.mercadoPagoPaymentId = mercadoPagoPaymentId; }

    public String getMercadoPagoPreferenceId() { return mercadoPagoPreferenceId; }
    public void setMercadoPagoPreferenceId(String mercadoPagoPreferenceId) { this.mercadoPagoPreferenceId = mercadoPagoPreferenceId; }

    public String getQrCode() { return qrCode; }
    public void setQrCode(String qrCode) { this.qrCode = qrCode; }

    public String getQrCodeBase64() { return qrCodeBase64; }
    public void setQrCodeBase64(String qrCodeBase64) { this.qrCodeBase64 = qrCodeBase64; }

    public LocalDateTime getDataProcessamento() { return dataProcessamento; }
    public void setDataProcessamento(LocalDateTime dataProcessamento) { this.dataProcessamento = dataProcessamento; }

    public LocalDateTime getDataVencimento() { return dataVencimento; }
    public void setDataVencimento(LocalDateTime dataVencimento) { this.dataVencimento = dataVencimento; }

    public String getObservacoes() { return observacoes; }
    public void setObservacoes(String observacoes) { this.observacoes = observacoes; }
}

//src/main/java/br/com/tourapp/entity/Notificacao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoNotificacao;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "notificacoes")
public class Notificacao extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "excursao_id")
    private Excursao excursao;

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 100, message = "Título deve ter entre 5 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String titulo;

    @NotBlank(message = "Mensagem é obrigatória")
    @Size(min = 10, max = 500, message = "Mensagem deve ter entre 10 e 500 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String mensagem;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TipoNotificacao tipo = TipoNotificacao.INFO;

    @Column(name = "enviada_em")
    private LocalDateTime enviadaEm;

    @ElementCollection
    @CollectionTable(name = "notificacao_clientes", joinColumns = @JoinColumn(name = "notificacao_id"))
    @Column(name = "cliente_id")
    private List<UUID> clientesAlvo;

    @Column(name = "enviar_para_todos", nullable = false)
    private Boolean enviarParaTodos = false;

    @Column(name = "enviada", nullable = false)
    private Boolean enviada = false;

    // Construtores
    public Notificacao() {}

    public Notificacao(Organizador organizador, String titulo, String mensagem, TipoNotificacao tipo) {
        this.organizador = organizador;
        this.titulo = titulo;
        this.mensagem = mensagem;
        this.tipo = tipo;
    }

    // Getters e Setters
    public Organizador getOrganizador() { return organizador; }
    public void setOrganizador(Organizador organizador) { this.organizador = organizador; }

    public Excursao getExcursao() { return excursao; }
    public void setExcursao(Excursao excursao) { this.excursao = excursao; }

    public String getTitulo() { return titulo; }
    public void setTitulo(String titulo) { this.titulo = titulo; }

    public String getMensagem() { return mensagem; }
    public void setMensagem(String mensagem) { this.mensagem = mensagem; }

    public TipoNotificacao getTipo() { return tipo; }
    public void setTipo(TipoNotificacao tipo) { this.tipo = tipo; }

    public LocalDateTime getEnviadaEm() { return enviadaEm; }
    public void setEnviadaEm(LocalDateTime enviadaEm) { this.enviadaEm = enviadaEm; }

    public List<UUID> getClientesAlvo() { return clientesAlvo; }
    public void setClientesAlvo(List<UUID> clientesAlvo) { this.clientesAlvo = clientesAlvo; }

    public Boolean getEnviarParaTodos() { return enviarParaTodos; }
    public void setEnviarParaTodos(Boolean enviarParaTodos) { this.enviarParaTodos = enviarParaTodos; }

    public Boolean getEnviada() { return enviada; }
    public void setEnviada(Boolean enviada) { this.enviada = enviada; }
}

//src/main/java/br/com/tourapp/config/SecurityConfig.java
package br.com.tourapp.config;

import br.com.tourapp.security.JwtAuthenticationFilter;
import br.com.tourapp.security.CustomUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(CustomUserDetailsService userDetailsService, 
                         JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // Endpoints públicos
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/webhook/**").permitAll()
                .requestMatchers("/health", "/actuator/health").permitAll()
                
                // Endpoints de organizador
                .requestMatchers("/organizador/**").hasRole("ORGANIZADOR")
                
                // Endpoints de cliente
                .requestMatchers("/cliente/**").hasRole("CLIENTE")
                
                // Endpoints administrativos (futuro)
                .requestMatchers("/admin/**").hasRole("ADMIN")
                
                // Todos os outros endpoints requerem autenticação
                .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

//src/main/java/br/com/tourapp/security/JwtUtil.java
package br.com.tourapp.security;

import br.com.tourapp.enums.TipoUsuario;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.expiration}")
    private int jwtExpiration;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUserId(String token) {
        return extractClaim(token, claims -> claims.get("userId", String.class));
    }

    public TipoUsuario extractTipoUsuario(String token) {
        String tipo = extractClaim(token, claims -> claims.get("tipoUsuario", String.class));
        return TipoUsuario.valueOf(tipo);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails, UUID userId, TipoUsuario tipoUsuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("tipoUsuario", tipoUsuario.name());
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSigningKey())
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}

//src/main/java/br/com/tourapp/security/JwtAuthenticationFilter.java
package br.com.tourapp.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request,
                                    @NonNull HttpServletResponse response,
                                    @NonNull FilterChain filterChain) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        userEmail = jwtUtil.extractUsername(jwt);

        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);

            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}

//src/main/java/br/com/tourapp/security/CustomUserDetailsService.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.repository.ClienteRepository;
import br.com.tourapp.repository.OrganizadorRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final ClienteRepository clienteRepository;
    private final OrganizadorRepository organizadorRepository;

    public CustomUserDetailsService(ClienteRepository clienteRepository, 
                                   OrganizadorRepository organizadorRepository) {
        this.clienteRepository = clienteRepository;
        this.organizadorRepository = organizadorRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // Primeiro tenta encontrar cliente
        Cliente cliente = clienteRepository.findByEmail(email).orElse(null);
        if (cliente != null) {
            return new SecurityUser(cliente);
        }

        // Se não encontrou cliente, tenta organizador
        Organizador organizador = organizadorRepository.findByEmail(email).orElse(null);
        if (organizador != null) {
            return new SecurityUser(organizador);
        }

        throw new UsernameNotFoundException("Usuário não encontrado com email: " + email);
    }
}

//src/main/java/br/com/tourapp/security/SecurityUser.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.TipoUsuario;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.UUID;

public class SecurityUser implements UserDetails {

    private final UUID id;
    private final String email;
    private final String senha;
    private final String nome;
    private final TipoUsuario tipoUsuario;
    private final boolean ativo;

    public SecurityUser(Cliente cliente) {
        this.id = cliente.getId();
        this.email = cliente.getEmail();
        this.senha = cliente.getSenha();
        this.nome = cliente.getNome();
        this.tipoUsuario = cliente.getTipoUsuario();
        this.ativo = cliente.getAtivo();
    }

    public SecurityUser(Organizador organizador) {
        this.id = organizador.getId();
        this.email = organizador.getEmail();
        this.senha = organizador.getSenha();
        this.nome = organizador.getNomeEmpresa();
        this.tipoUsuario = organizador.getTipoUsuario();
        this.ativo = organizador.getStatus().name().equals("ATIVO");
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + tipoUsuario.name()));
    }

    @Override
    public String getPassword() {
        return senha;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return ativo;
    }

    // Getters adicionais
    public UUID getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    public String getNome() {
        return nome;
    }

    public TipoUsuario getTipoUsuario() {
        return tipoUsuario;
    }
}

//src/main/java/br/com/tourapp/repository/ClienteRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, UUID> {
    
    Optional<Cliente> findByEmail(String email);
    
    boolean existsByEmail(String email);
}

//src/main/java/br/com/tourapp/repository/OrganizadorRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.StatusOrganizador;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface OrganizadorRepository extends JpaRepository<Organizador, UUID> {
    
    Optional<Organizador> findByEmail(String email);
    
    boolean existsByEmail(String email);
    
    List<Organizador> findByStatus(StatusOrganizador status);
}

//src/main/java/br/com/tourapp/repository/ExcursaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Excursao;
import br.com.tourapp.enums.StatusExcursao;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ExcursaoRepository extends JpaRepository<Excursao, UUID> {
    
    Page<Excursao> findByOrganizadorId(UUID organizadorId, Pageable pageable);
    
    Page<Excursao> findByOrganizadorIdAndStatus(UUID organizadorId, StatusExcursao status, Pageable pageable);
    
    Optional<Excursao> findByIdAndOrganizadorId(UUID id, UUID organizadorId);
    
    List<Excursao> findByStatus(StatusExcursao status);
    
    @Query("SELECT e FROM Excursao e WHERE e.status = :status AND e.dataSaida BETWEEN :inicio AND :fim")
    List<Excursao> findByStatusAndDataSaidaBetween(@Param("status") StatusExcursao status, 
                                                   @Param("inicio") LocalDateTime inicio, 
                                                   @Param("fim") LocalDateTime fim);
}

//src/main/java/br/com/tourapp/repository/InscricaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Inscricao;
import br.com.tourapp.enums.StatusPagamento;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.//pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.3</version>
        <relativePath/>
    </parent>
    
    <groupId>br.com.tourapp</groupId>
    <artifactId>tourapp-backend</artifactId>
    <version>1.0.0</version>
    <name>TourApp Backend</name>
    <description>Sistema de gerenciamento de excursões</description>
    
    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.6</version>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Mercado Pago SDK -->
        <dependency>
            <groupId>com.mercadopago</groupId>
            <artifactId>sdk-java</artifactId>
            <version>2.1.29</version>
        </dependency>
        
        <!-- Cloudinary -->
        <dependency>
            <groupId>com.cloudinary</groupId>
            <artifactId>cloudinary-http45</artifactId>
            <version>2.5.1</version>
        </dependency>
        
        <!-- Firebase Admin -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.4.1</version>
        </dependency>
        
        <!-- Utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>3.2.1</version>
        </dependency>
        
        <!-- Micrometer para métricas -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>
        
        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <configuration>
                    <url>${DB_URL}</url>
                    <user>${DB_USER}</user>
                    <password>${DB_PASSWORD}</password>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

//src/main/resources/application.yml
spring:
  application:
    name: tourapp
  
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  
  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/tourapp}
    username: ${DB_USER:tourapp}
    password: ${DB_PASSWORD:tourapp123}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      connection-timeout: 20000
      validation-timeout: 5000
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
        use_sql_comments: true
    defer-datasource-initialization: false
  
  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration
    validate-on-migrate: true
  
  mail:
    host: ${MAIL_HOST:smtp.gmail.com}
    port: ${MAIL_PORT:587}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
  
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  
  # Virtual Threads (JDK 21 feature)
  threads:
    virtual:
      enabled: true

server:
  port: ${PORT:8080}
  servlet:
    context-path: /api
  # Habilitar HTTP/2 e compressão
  http2:
    enabled: true
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css
  error:
    include-stacktrace: never
    include-exception: false

# Configurações customizadas
app:
  jwt:
    secret: ${JWT_SECRET:tourapp-super-secret-key-change-in-production}
    expiration: ${JWT_EXPIRATION:86400000} # 24 horas em ms
  
  cors:
    allowed-origins: ${CORS_ORIGINS:http://localhost:3000,https://tourapp.vercel.app}
    allowed-methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
    allowed-headers: "*"
    allow-credentials: true
  
  mercadopago:
    access-token: ${MERCADOPAGO_ACCESS_TOKEN:}
    public-key: ${MERCADOPAGO_PUBLIC_KEY:}
    webhook-secret: ${MERCADOPAGO_WEBHOOK_SECRET:}
    sandbox: ${MERCADOPAGO_SANDBOX:true}
  
  cloudinary:
    cloud-name: ${CLOUDINARY_CLOUD_NAME:}
    api-key: ${CLOUDINARY_API_KEY:}
    api-secret: ${CLOUDINARY_API_SECRET:}
    secure: true
  
  firebase:
    service-account-path: ${FIREBASE_SERVICE_ACCOUNT_PATH:classpath:firebase-service-account.json}
  
  frontend:
    base-url: ${FRONTEND_BASE_URL:http://localhost:3000}
  
  file:
    upload-dir: ${UPLOAD_DIR:./uploads}
  
  cache:
    enabled: ${CACHE_ENABLED:true}
    ttl: ${CACHE_TTL:3600} # 1 hora

# Logging com melhor performance
logging:
  level:
    br.com.tourapp: ${LOG_LEVEL:INFO}
    org.springframework.security: ${SECURITY_LOG_LEVEL:WARN}
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: ${SQL_PARAMS_LOG_LEVEL:WARN}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: ${LOG_FILE:logs/tourapp.log}

# Management endpoints com security
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when_authorized
      show-components: when_authorized
    metrics:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

//src/main/java/br/com/tourapp/TourappApplication.java
package br.com.tourapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaAuditing
@EnableAsync
@EnableScheduling
public class TourappApplication {

    public static void main(String[] args) {
        SpringApplication.run(TourappApplication.class, args);
    }
}

//src/main/java/br/com/tourapp/entity/BaseEntity.java
package br.com.tourapp.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    // Getters e Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Long getVersion() {
        return version;
    }

    public void setVersion(Long version) {
        this.version = version;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BaseEntity)) return false;
        BaseEntity that = (BaseEntity) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}

//src/main/java/br/com/tourapp/enums/StatusOrganizador.java
package br.com.tourapp.enums;

public enum StatusOrganizador {
    PENDENTE("Pendente de aprovação"),
    ATIVO("Ativo"),
    INATIVO("Inativo"),
    SUSPENSO("Suspenso");

    private final String descricao;

    StatusOrganizador(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusExcursao.java
package br.com.tourapp.enums;

public enum StatusExcursao {
    RASCUNHO("Rascunho"),
    ATIVA("Ativa"),
    LOTADA("Lotada"),
    CANCELADA("Cancelada"),
    FINALIZADA("Finalizada");

    private final String descricao;

    StatusExcursao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusPagamento.java
package br.com.tourapp.enums;

public enum StatusPagamento {
    PENDENTE("Pendente"),
    PROCESSANDO("Processando"),
    APROVADO("Aprovado"),
    REJEITADO("Rejeitado"),
    CANCELADO("Cancelado"),
    REEMBOLSADO("Reembolsado"),
    EXPIRADO("Expirado");

    private final String descricao;

    StatusPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/MetodoPagamento.java
package br.com.tourapp.enums;

public enum MetodoPagamento {
    PIX("PIX"),
    CARTAO_CREDITO("Cartão de Crédito"),
    CARTAO_DEBITO("Cartão de Débito"),
    BOLETO("Boleto"),
    DINHEIRO("Dinheiro");

    private final String descricao;

    MetodoPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoNotificacao.java
package br.com.tourapp.enums;

public enum TipoNotificacao {
    INFO("Informação"),
    PROMOCAO("Promoção"),
    LEMBRETE("Lembrete"),
    URGENTE("Urgente"),
    CONFIRMACAO("Confirmação"),
    CANCELAMENTO("Cancelamento");

    private final String descricao;

    TipoNotificacao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoUsuario.java
package br.com.tourapp.enums;

public enum TipoUsuario {
    CLIENTE("Cliente"),
    ORGANIZADOR("Organizador"),
    ADMIN("Administrador");

    private final String descricao;

    TipoUsuario(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/entity/Cliente.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "clientes")
public class Cliente extends BaseEntity {

    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String nome;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "push_token")
    private String pushToken;

    @Column(name = "email_notifications", nullable = false)
    private Boolean emailNotifications = true;

    @Column(name = "sms_notifications", nullable = false)
    private Boolean smsNotifications = true;

    @Column(name = "ativo", nullable = false)
    private Boolean ativo = true;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.CLIENTE;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Cliente() {}

    public Cliente(String nome, String email, String senha) {
        this.nome = nome;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPushToken() { return pushToken; }
    public void setPushToken(String pushToken) { this.pushToken = pushToken; }

    public Boolean getEmailNotifications() { return emailNotifications; }
    public void setEmailNotifications(Boolean emailNotifications) { this.emailNotifications = emailNotifications; }

    public Boolean getSmsNotifications() { return smsNotifications; }
    public void setSmsNotifications(Boolean smsNotifications) { this.smsNotifications = smsNotifications; }

    public Boolean getAtivo() { return ativo; }
    public void setAtivo(Boolean ativo) { this.ativo = ativo; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Organizador.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusOrganizador;
import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "organizadores")
public class Organizador extends BaseEntity {

    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 150, message = "Nome da empresa deve ter entre 2 e 150 caracteres")
    @Column(name = "nome_empresa", nullable = false, length = 150)
    private String nomeEmpresa;

    @NotBlank(message = "Nome do responsável é obrigatório")
    @Size(min = 2, max = 100, message = "Nome do responsável deve ter entre 2 e 100 caracteres")
    @Column(name = "nome_responsavel", nullable = false, length = 100)
    private String nomeResponsavel;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "pix_key", length = 100)
    private String pixKey;

    @Size(max = 18, message = "CNPJ deve ter no máximo 18 caracteres")
    @Column(length = 18)
    private String cnpj;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusOrganizador status = StatusOrganizador.PENDENTE;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.ORGANIZADOR;

    @OneToMany(mappedBy = "organizador", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Excursao> excursoes;

    // Construtores
    public Organizador() {}

    public Organizador(String nomeEmpresa, String nomeResponsavel, String email, String senha) {
        this.nomeEmpresa = nomeEmpresa;
        this.nomeResponsavel = nomeResponsavel;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNomeEmpresa() { return nomeEmpresa; }
    public void setNomeEmpresa(String nomeEmpresa) { this.nomeEmpresa = nomeEmpresa; }

    public String getNomeResponsavel() { return nomeResponsavel; }
    public void setNomeResponsavel(String nomeResponsavel) { this.nomeResponsavel = nomeResponsavel; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPixKey() { return pixKey; }
    public void setPixKey(String pixKey) { this.pixKey = pixKey; }

    public String getCnpj() { return cnpj; }
    public void setCnpj(String cnpj) { this.cnpj = cnpj; }

    public StatusOrganizador getStatus() { return status; }
    public void setStatus(StatusOrganizador status) { this.status = status; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Excursao> getExcursoes() { return excursoes; }
    public void setExcursoes(List<Excursao> excursoes) { this.excursoes = excursoes; }
}

//src/main/java/br/com/tourapp/entity/Excursao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusExcursao;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "excursoes")
public class Excursao extends BaseEntity {

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 200, message = "Título deve ter entre 5 e 200 caracteres")
    @Column(nullable = false, length = 200)
    private String titulo;

    @NotBlank(message = "Descrição é obrigatória")
    @Size(min = 10, max = 2000, message = "Descrição deve ter entre 10 e 2000 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String descricao;

    @NotNull(message = "Data de saída é obrigatória")
    @Future(message = "Data de saída deve ser no futuro")
    @Column(name = "data_saida", nullable = false)
    private LocalDateTime dataSaida;

    @Column(name = "data_retorno")
    private LocalDateTime dataRetorno;

    @NotNull(message = "Preço é obrigatório")
    @DecimalMin(value = "0.01", message = "Preço deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal preco;

    @NotNull(message = "Total de vagas é obrigatório")
    @Min(value = 1, message = "Deve ter pelo menos 1 vaga")
    @Column(name = "vagas_total", nullable = false)
    private Integer vagasTotal;

    @Column(name = "vagas_ocupadas", nullable = false)
    private Integer vagasOcupadas = 0;

    @Column(name = "local_saida", length = 300)
    private String localSaida;

    @Column(name = "local_destino", length = 300)
    private String localDestino;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    @ElementCollection
    @CollectionTable(name = "excursao_imagens", joinColumns = @JoinColumn(name = "excursao_id"))
    @Column(name = "url_imagem")
    private List<String> imagens;

    @Column(name = "aceita_pix", nullable = false)
    private Boolean aceitaPix = true;

    @Column(name = "aceita_cartao", nullable = false)
    private Boolean aceitaCartao = true;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusExcursao status = StatusExcursao.RASCUNHO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @OneToMany(mappedBy = "excursao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Excursao() {}

    public Excursao(String titulo, String descricao, LocalDateTime dataSaida, BigDecimal preco, 
                    Integer vagasTotal, Organizador organizador) {
        this.titulo = titulo;
        this.descricao = descricao;
        this.dataSaida = dataSaida;
        this.preco = preco;
        this.vagasTotal = vagasTotal;
        this.organizador = organizador;
    }

    // Métodos auxiliares
    public Integer getVagasDisponiveis() {
        return vagasTotal - vagasOcupadas;
    }

    public boolean temVagasDisponiveis() {
        return getVagasDisponiveis() > 0;
    }

    public boolean isAtiva() {
        return status == StatusExcursao.ATIVA;
    }


    import java.util.Optional;
import java.util.UUID;

@Repository
public interface InscricaoRepository extends JpaRepository<Inscricao, UUID> {
    
    Page<Inscricao> findByClienteId(UUID clienteId, Pageable pageable);
    
    Page<Inscricao> findByExcursaoId(UUID excursaoId, Pageable pageable);
    
    @Query("SELECT i FROM Inscricao i WHERE i.excursao.organizador.id = :organizadorId")
    Page<Inscricao> findByOrganizadorId(@Param("organizadorId") UUID organizadorId, Pageable pageable);
    
    @Query("SELECT i FROM Inscricao i WHERE i.excursao.organizador.id = :organizadorId AND i.excursao.id = :excursaoId")
    Page<Inscricao> findByOrganizadorIdAndExcursaoId(@Param("organizadorId") UUID organizadorId, 
                                                     @Param("excursaoId") UUID excursaoId, Pageable pageable);
    
    Optional<Inscricao> findByIdAndClienteId(UUID id, UUID clienteId);
    
    boolean existsByClienteIdAndExcursaoId(UUID clienteId, UUID excursaoId);
    
    List<Inscricao> findByStatusPagamento(StatusPagamento status);
    
    long countByExcursaoId(UUID excursaoId);
}

//src/main/java/br/com/tourapp/repository/PagamentoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Pagamento;
import br.com.tourapp.enums.StatusPagamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface PagamentoRepository extends JpaRepository<Pagamento, UUID> {
    
    List<Pagamento> findByInscricaoId(UUID inscricaoId);
    
    Optional<Pagamento> findByMercadoPagoPaymentId(String mercadoPagoPaymentId);
    
    List<Pagamento> findByStatus(StatusPagamento status);
}

//src/main/java/br/com/tourapp/repository/NotificacaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Notificacao;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface NotificacaoRepository extends JpaRepository<Notificacao, UUID> {
    
    Page<Notificacao> findByOrganizadorId(UUID organizadorId, Pageable pageable);
    
    List<Notificacao> findByEnviadaFalse();
}

//src/main/java/br/com/tourapp/service/AuthService.java
package br.com.tourapp.service;

import br.com.tourapp.dto.request.CadastroClienteRequest;
import br.com.tourapp.dto.request.CadastroOrganizadorRequest;
import br.com.tourapp.dto.request.LoginRequest;
import br.com.tourapp.dto.response.AuthResponse;
import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.StatusOrganizador;
import br.com.tourapp.enums.TipoUsuario;
import br.com.tourapp.exception.BusinessException;
import br.com.tourapp.exception.UnauthorizedException;
import br.com.tourapp.repository.ClienteRepository;
import br.com.tourapp.repository.OrganizadorRepository;
import br.com.tourapp.security.JwtUtil;
import br.com.tourapp.security.SecurityUser;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class AuthService {

    private final ClienteRepository clienteRepository;
    private final OrganizadorRepository organizadorRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    public AuthService(ClienteRepository clienteRepository,
                      OrganizadorRepository organizadorRepository,
                      PasswordEncoder passwordEncoder,
                      JwtUtil jwtUtil,
                      AuthenticationManager authenticationManager) {
        this.clienteRepository = clienteRepository;
        this.organizadorRepository = organizadorRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtUtil = jwtUtil;
        this.authenticationManager = authenticationManager;
    }

    public AuthResponse login(LoginRequest request) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getEmail(), request.getSenha())
            );

            SecurityUser user = (SecurityUser) authentication.getPrincipal();
            String token = jwtUtil.generateToken(user, user.getId(), user.getTipoUsuario());

            return new AuthResponse(
                token,
                user.getTipoUsuario(),
                user.getId(),
                user.getNome(),
                user.getEmail()
            );

        } catch (Exception e) {
            throw new UnauthorizedException("Email ou senha inválidos");
        }
    }

    public AuthResponse cadastrarCliente(CadastroClienteRequest request) {
        // Verificar se o email já existe
        if (clienteRepository.existsByEmail(request.getEmail()) || 
            organizadorRepository.existsByEmail(request.getEmail())) {
            throw new BusinessException("Email já está em uso");
        }

        // Criar novo cliente
        Cliente cliente = new Cliente();
        cliente.setNome(request.getNome());
        cliente.setEmail(request.getEmail());
        cliente.setSenha(passwordEncoder.encode(request.getSenha()));
        cliente.setTelefone(request.getTelefone());

        cliente = clienteRepository.save(cliente);

        // Gerar token
        SecurityUser user = new SecurityUser(cliente);
        String token = jwtUtil.generateToken(user, cliente.getId(), TipoUsuario.CLIENTE);

        return new AuthResponse(
            token,
            TipoUsuario.CLIENTE,
            cliente.getId(),
            cliente.getNome(),
            cliente.getEmail()
        );
    }

    public AuthResponse cadastrarOrganizador(CadastroOrganizadorRequest request) {
        // Verificar se o email já existe
        if (clienteRepository.existsByEmail(request.getEmail()) || 
            organizadorRepository.existsByEmail(request.getEmail())) {
            throw new BusinessException("Email já está em uso");
        }

        // Criar novo organizador
        Organizador organizador = new Organizador();
        organizador.setNomeEmpresa(request.getNomeEmpresa());
        organizador.setNomeResponsavel(request.getNomeResponsavel());
        organizador.setEmail(request.getEmail());
        organizador.setSenha(passwordEncoder.encode(request.getSenha()));
        organizador.setTelefone(request.getTelefone());
        organizador.setPixKey(request.getPixKey());
        organizador.setCnpj(request.getCnpj());
        organizador.setStatus(StatusOrganizador.ATIVO); // Para MVP, aprovar automaticamente

        organizador = organizadorRepository.save(organizador);

        // Gerar token
        SecurityUser user = new SecurityUser(organizador);
        String token = jwtUtil.generateToken(user, organizador.getId(), TipoUsuario.ORGANIZADOR);

        return new AuthResponse(
            token,
            TipoUsuario.ORGANIZADOR,
            organizador.getId(),
            organizador.getNomeEmpresa(),
            organizador.getEmail()
        );
    }

    public AuthResponse refreshToken(String bearerToken) {
        String token = bearerToken.replace("Bearer ", "");
        
        if (!jwtUtil.validateToken(token)) {
            throw new UnauthorizedException("Token inválido");
        }

        String email = jwtUtil.extractUsername(token);
        TipoUsuario tipoUsuario = jwtUtil.extractTipoUsuario(token);

        SecurityUser user;
        String nome;

        if (tipoUsuario == TipoUsuario.CLIENTE) {
            Cliente cliente = clienteRepository.findByEmail(email)
                .orElseThrow(() -> new UnauthorizedException("Usuário não encontrado"));
            user = new SecurityUser(cliente);
            nome = cliente.getNome();
        } else {
            Organizador organizador = organizadorRepository.findByEmail(email)
                .orElseThrow(() -> new UnauthorizedException("Usuário não encontrado"));
            user = new SecurityUser(organizador);
            nome = organizador.getNomeEmpresa();
        }

        String newToken = jwtUtil.generateToken(user, user.getId(), user.getTipoUsuario());

        return new AuthResponse(
            newToken,
            user.getTipoUsuario(),
            user.getId(),
            nome,
            user.getEmail()
        );
    }
}

//src/main/java/br/com/tourapp/dto/request/LoginRequest.java
package br.com.tourapp.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    
    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    private String email;
    
    @NotBlank(message = "Senha é obrigatória")
    private String senha;

    // Construtores
    public LoginRequest() {}

    public LoginRequest(String email, String senha) {
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }
}

//src/main/java/br/com/tourapp/dto/request/CadastroClienteRequest.java
package br.com.tourapp.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class CadastroClienteRequest {
    
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    private String nome;
    
    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    private String email;
    
    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    private String senha;
    
    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    private String telefone;

    // Construtores
    public CadastroClienteRequest() {}

    // Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
}

//src/main/java/br/com/tourapp/dto/request/CadastroOrganizadorRequest.java
package br.com.tourapp.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class CadastroOrganizadorRequest {
    
    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 150, message = "Nome da empresa deve ter entre 2 e 150 caracteres")
    private String nomeEmpresa;
    
    @NotBlank(message = "Nome do responsável é obrigatório")
    @Size(min = 2, max = 100, message = "Nome do responsável deve ter entre 2 e 100 caracteres")
    private String nomeResponsavel;
    
    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    private String email;
    
    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    private String senha;
    
    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    private String telefone;
    
    @Size(max = 100, message = "Chave PIX deve ter no máximo 100 caracteres")
    private String pixKey;
    
    @Size(max = 18, message = "CNPJ deve ter no máximo 18 caracteres")
    private String cnpj;

    // Construtores
    public CadastroOrganizadorRequest() {}

    // Getters e Setters
    public String getNomeEmpresa() { return nomeEmpresa; }
    public void setNomeEmpresa(String nomeEmpresa) { this.nomeEmpresa = nomeEmpresa; }

    public String getNomeResponsavel() { return nomeResponsavel; }
    public void setNomeResponsavel(String nomeResponsavel) { this.nomeResponsavel = nomeResponsavel; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPixKey() { return pixKey; }
    public void setPixKey(String pixKey) { this.pixKey = pixKey; }

    public String getCnpj() { return cnpj; }
    public void setCnpj(String cnpj) { this.cnpj = cnpj; }
}

//src/main/java/br/com/tourapp/dto/response/AuthResponse.java
package br.com.tourapp.dto.response;

import br.com.tourapp.enums.TipoUsuario;

import java.util.UUID;

public class AuthResponse {
    
    private String token;
    private TipoUsuario tipoUsuario;
    private UUID userId;
    private String nome;
    private String email;

    // Construtores
    public AuthResponse() {}

    public AuthResponse(String token, TipoUsuario tipoUsuario, UUID userId, String nome, String email) {
        this.token = token;
        this.tipoUsuario = tipoUsuario;
        this.userId = userId;
        this.nome = nome;
        this.email = email;
    }

    // Getters e Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public UUID getUserId() { return userId; }
    public void setUserId(UUID userId) { this.userId = userId; }

    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

//src/main/java/br/com/tourapp/controller/AuthController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.CadastroClienteRequest;
import br.com.tourapp.dto.request.CadastroOrganizadorRequest;
import br.com.tourapp.dto.request.LoginRequest;
import br.com.tourapp.dto.response.AuthResponse;
import br.com.tourapp.service.AuthService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest request) {
        AuthResponse response = authService.login(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cadastro/cliente")
    public ResponseEntity<AuthResponse> cadastroCliente(@Valid @RequestBody CadastroClienteRequest request) {
        AuthResponse response = authService.cadastrarCliente(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cadastro/organizador")
    public ResponseEntity<AuthResponse> cadastroOrganizador(@Valid @RequestBody CadastroOrganizadorRequest request) {
        AuthResponse response = authService.cadastrarOrganizador(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthResponse> refresh(@RequestHeader("Authorization") String token) {
        AuthResponse response = authService.refreshToken(token);
        return ResponseEntity.ok(response);
    }
}

//src/main/java/br/com/tourapp/controller/PublicController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.InscricaoRequest;
import br.com.tourapp.dto.response.ExcursaoResponse;
import br.com.tourapp.dto.response.InscricaoResponse;
import br.com.tourapp.service.ExcursaoService;
import br.com.tourapp.service.InscricaoService;
import br.com.tourapp.security.SecurityUser;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/public")
@CrossOrigin(origins = "*")
public class PublicController {

    private final ExcursaoService excursaoService;
    private final InscricaoService inscricaoService;

    public PublicController(ExcursaoService excursaoService, InscricaoService inscricaoService) {
        this.excursaoService = excursaoService;
        this.inscricaoService = inscricaoService;
    }

    @GetMapping("/excursoes/{id}")
    public ResponseEntity<ExcursaoResponse> obterExcursaoPublica(@PathVariable UUID id) {
        ExcursaoResponse response = excursaoService.obterExcursaoPublica(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/excursoes/{excursaoId}/inscricoes")
    public ResponseEntity<InscricaoResponse> inscreverNaExcursao(
            @PathVariable UUID excursaoId,
            @Valid @RequestBody InscricaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        InscricaoResponse response = inscricaoService.criarInscricao(excursaoId, request, user.getId());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("OK");
    }
}

//src/main/java/br/com/tourapp/exception/GlobalExceptionHandler.java
package br.com.tourapp.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.badRequest().body(error);
    }

    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.notFound().build();
    }

    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(UnauthorizedException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.UNAUTHORIZED.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ValidationErrorResponse validationError = new ValidationErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Erro de validação",
            LocalDateTime.now(),
            errors
        );
        return ResponseEntity.badRequest().body(validationError);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Erro interno do servidor",
            LocalDateTime.now()
        );
        return ResponseEntity.internalServerError().body(error);
    }

    // Classes de resposta de erro
    public static class ErrorResponse {
        private int status;
        private String message;
        private LocalDateTime timestamp;

        public ErrorResponse(int status, String message, LocalDateTime timestamp) {
            this.status = status;
            this.message = message;
            this.timestamp = timestamp;
        }

        // Getters e Setters
        public int getStatus() { return status; }
        public void setStatus(int status) { this.status = status; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    }

    public static class ValidationErrorResponse extends ErrorResponse {
        private Map<String, String> errors;

        public ValidationErrorResponse(int status, String message, LocalDateTime timestamp, Map<String, String> errors) {
            super(status, message, timestamp);
            this.errors = errors;
        }

        public Map<String, String> getErrors() { return errors; }
        public void setErrors(Map<String, String> errors) { this.errors = errors; }
    }
}

//src/main/java/br/com/tourapp/exception/BusinessException.java
package br.com.tourapp.exception;

public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }
}

//src/main/java/br/com/tourapp/exception/NotFoundException.java
package br.com.tourapp.exception;

public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}

//src/main/java/br/com/tourapp/exception/UnauthorizedException.java
package br.com.tourapp.exception;

public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}

//src/main/resources/db/migration/V1__create_cliente_table.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE clientes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    senha VARCHAR(255) NOT NULL,
    telefone VARCHAR(20),
    push_token VARCHAR(255),
    email_notifications BOOLEAN NOT NULL DEFAULT true,
    sms_notifications BOOLEAN NOT NULL DEFAULT true,
    ativo BOOLEAN NOT NULL DEFAULT true,
    tipo_usuario VARCHAR(20) NOT NULL DEFAULT 'CLIENTE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0
);

CREATE INDEX idx_clientes_email ON clientes(email);
CREATE INDEX idx_clientes_ativo ON clientes(ativo);

//src/main/resources/db/migration/V2__create_organizador_table.sql
CREATE TABLE organizadores (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome_empresa VARCHAR(150) NOT NULL,
    nome_responsavel VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    senha VARCHAR(255) NOT NULL,
    telefone VARCHAR(20),
    pix_key VARCHAR(100),
    cnpj VARCHAR(18),
    status VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    tipo_usuario VARCHAR(20) NOT NULL DEFAULT 'ORGANIZADOR',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0
);

CREATE INDEX idx_organizadores_email ON organizadores(email);
CREATE INDEX idx_organizadores_status ON organizadores(status);

//src/main/resources/db/migration/V3__create_excursao_table.sql
CREATE TABLE excursoes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organizador_id UUID NOT NULL REFERENCES organizadores(id) ON DELETE CASCADE,
    titulo VARCHAR(200) NOT NULL,
    descricao TEXT NOT NULL,
    data_saida TIMESTAMP NOT NULL,
    data_retorno TIMESTAMP,
    preco DECIMAL(10,2) NOT NULL,
    vagas_total INTEGER NOT NULL,
    vagas_ocupadas INTEGER NOT NULL DEFAULT 0,
    local_saida VARCHAR(300),
    local_destino VARCHAR(300),
    observacoes TEXT,
    aceita_pix BOOLEAN NOT NULL DEFAULT true,
    aceita_cartao BOOLEAN NOT NULL DEFAULT true,
    status VARCHAR(20) NOT NULL DEFAULT 'RASCUNHO',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0,
    
    CONSTRAINT chk_vagas_ocupadas CHECK (vagas_ocupadas >= 0),
    CONSTRAINT chk_vagas_total CHECK (vagas_total > 0),
    CONSTRAINT chk_vagas_ocupadas_menor_total CHECK (vagas_ocupadas <= vagas_total),
    CONSTRAINT chk_preco_positivo CHECK (preco > 0)
);

CREATE INDEX idx_excursoes_organizador ON excursoes(organizador_id);
CREATE INDEX idx_excursoes_status ON excursoes(status);
CREATE INDEX idx_excursoes_data_saida ON excursoes(data_saida);
CREATE INDEX idx_excursoes_ativas ON excursoes(status, data_saida) WHERE status = 'ATIVA';

CREATE TABLE excursao_imagens (
    excursao_id UUID NOT NULL REFERENCES excursoes(id) ON DELETE CASCADE,
    url_imagem VARCHAR(500) NOT NULL,
    PRIMARY KEY (excursao_id, url_imagem)
);

//src/main/resources/db/migration/V4__create_inscricao_table.sql
CREATE TABLE inscricoes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    excursao_id UUID NOT NULL REFERENCES excursoes(id) ON DELETE CASCADE,
    cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
    valor_pago DECIMAL(10,2) NOT NULL,
    status_pagamento VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    observacoes_cliente TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0,
    
    CONSTRAINT chk_valor_pago_positivo CHECK (valor_pago > 0),
    CONSTRAINT uk_inscricao_cliente_excursao UNIQUE (cliente_id, excursao_id)
);

CREATE INDEX idx_inscricoes_excursao ON inscricoes(excursao_id);
CREATE INDEX idx_inscricoes_cliente ON inscricoes(cliente_id);
CREATE INDEX idx_inscricoes_status ON inscricoes(status_pagamento);

//src/main/resources/db/migration/V5__create_pagamento_table.sql
CREATE TABLE pagamentos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    inscricao_id UUID NOT NULL REFERENCES inscricoes(id) ON DELETE CASCADE,
    valor DECIMAL(10,2) NOT NULL,
    metodo_pagamento VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    mercadopago_payment_id VARCHAR(100),
    mercadopago_preference_id VARCHAR(100),
    qr_code VARCHAR(500),
    qr_code_base64 TEXT,
    data_processamento TIMESTAMP,
    data_vencimento TIMESTAMP,
    observacoes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0,
    
    CONSTRAINT chk_valor_positivo CHECK (valor > 0)
);

CREATE INDEX idx_pagamentos_inscricao ON pagamentos(inscricao_id);
CREATE INDEX idx_pagamentos_status ON pagamentos(status);
CREATE INDEX idx_pagamentos_mercadopago ON pagamentos(mercadopago_payment_id);
CREATE INDEX idx_pagamentos_metodo ON pagamentos(metodo_pagamento);

//src/main/resources/db/migration/V6__create_notificacao_table.sql
CREATE TABLE notificacoes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organizador_id UUID NOT NULL REFERENCES organizadores(id) ON DELETE CASCADE,
    excursao_id UUID REFERENCES excursoes(id) ON DELETE CASCADE,
    titulo VARCHAR(100) NOT NULL,
    mensagem TEXT NOT NULL,
    tipo VARCHAR(20) NOT NULL DEFAULT 'INFO',
    enviada_em TIMESTAMP,
    enviar_para_todos BOOLEAN NOT NULL DEFAULT false,
    enviada BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    version BIGINT DEFAULT 0
);

CREATE INDEX idx_notificacoes_organizador ON notificacoes(organizador_id);
CREATE INDEX idx_notificacoes_excursao ON notificacoes(excursao_id);
CREATE INDEX idx_notificacoes_enviada ON notificacoes(enviada);
CREATE INDEX idx_notificacoes_tipo ON notificacoes(tipo);

CREATE TABLE notificacao_clientes (
    notificacao_id UUID NOT NULL REFERENCES notificacoes(id) ON DELETE CASCADE,
    cliente_id UUID NOT NULL,
    PRIMARY KEY (notificacao_id, cliente_id)
);

//src/main/resources/db/migration/V7__insert_initial_data.sql
-- Inserir dados iniciais para testes (opcional)

-- Organizador de teste
INSERT INTO organizadores (
    id, nome_empresa, nome_responsavel, email, senha, telefone, pix_key, status
) VALUES (
    uuid_generate_v4(),
    'Turismo Aventura',
    'João Silva',
    'joao@turismoaventura.com',
    '$2a$10$N.zmdr9k7uH7NOARz4dBx.N5K9fxDn.lKNa6XMTtmCF5ZEaQBj2IW', -- senha: 123456
    '(11) 99999-9999',
    'joao@turismoaventura.com',
    'ATIVO'
);

-- Cliente de teste
INSERT INTO clientes (
    id, nome, email, senha, telefone
) VALUES (
    uuid_generate_v4(),
    'Maria Santos',
    'maria@email.com',
    '$2a$10$N.zmdr9k7uH7NOARz4dBx.N5K9fxDn.lKNa6XMTtmCF5ZEaQBj2IW', -- senha: 123456
    '(11) 88888-8888'
);

-- Trigger para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$ language 'plpgsql';

CREATE TRIGGER update_clientes_updated_at BEFORE UPDATE ON clientes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizadores_updated_at BEFORE UPDATE ON organizadores
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_excursoes_updated_at BEFORE UPDATE ON excursoes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_inscricoes_updated_at BEFORE UPDATE ON inscricoes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_pagamentos_updated_at BEFORE UPDATE ON pagamentos
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notificacoes_updated_at BEFORE UPDATE ON notificacoes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

//Dockerfile
FROM openjdk:21-jdk-slim

# Instalar dependências necessárias
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Criar diretório da aplicação
WORKDIR /app

# Copiar arquivos de configuração do Maven
COPY pom.xml .
COPY .mvn .mvn
COPY mvnw .

# Dar permissão de execução para o Maven wrapper
RUN chmod +x mvnw

# Baixar dependências
RUN ./mvnw dependency:go-offline -B

# Copiar código fonte
COPY src src

# Build da aplicação
RUN ./mvnw clean package -DskipTests

# Expor porta
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/api/health || exit 1

# Comando para iniciar a aplicação com otimizações para JDK 21
ENTRYPOINT ["java", \
    "--enable-preview", \
    "-XX:+UseZGC", \
    "-XX:+UnlockExperimentalVMOptions", \
    "-Xms512m", \
    "-Xmx1024m", \
    "-jar", "target/tourapp-backend-1.0.0.jar"]

//docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - DB_URL=jdbc:postgresql://db:5432/tourapp
      - DB_USER=tourapp
      - DB_PASSWORD=tourapp123
      - JWT_SECRET=tourapp-docker-secret-key-change-in-production
      - MERCADOPAGO_ACCESS_TOKEN=${MERCADOPAGO_ACCESS_TOKEN}
      - MERCADOPAGO_PUBLIC_KEY=${MERCADOPAGO_PUBLIC_KEY}
      - CLOUDINARY_CLOUD_NAME=${CLOUDINARY_CLOUD_NAME}
      - CLOUDINARY_API_KEY=${CLOUDINARY_API_KEY}
      - CLOUDINARY_API_SECRET=${CLOUDINARY_API_SECRET}
      - JAVA_OPTS=--enable-preview -XX:+UseZGC -Xms512m -Xmx1024m
    depends_on:
      db:
        condition: service_healthy
    networks:
      - tourapp-network
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: tourapp
      POSTGRES_USER: tourapp
      POSTGRES_PASSWORD: tourapp123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - tourapp-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U tourapp -d tourapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - tourapp-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

networks:
  tourapp-network:
    driver: bridge

//railway.json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "./mvnw clean package -DskipTests"
  },
  "deploy": {
    "startCommand": "java -jar target/tourapp-backend-1.0.0.jar",
    "healthcheckPath": "/api/health",
    "healthcheckTimeout": 300,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 3
  }
}

//.gitignore
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment ###
.env
.env.local
.env.production

### Logs ###
logs/
*.log

### OS ###
.DS_Store
Thumbs.db

### Firebase ###
firebase-service-account.json

### Uploads ###
uploads/

//README.md
# TourApp Backend

Sistema de gerenciamento de excursões desenvolvido em Spring Boot 3.5.3 com JDK 21.

## 🚀 Funcionalidades

### Para Clientes
- ✅ Cadastro e autenticação
- ✅ Visualização de excursões públicas
- ✅ Inscrição em excursões
- ✅ Pagamento via PIX e Cartão de Crédito
- ✅ Área do cliente com histórico
- ✅ Notificações push e email

### Para Organizadores
- ✅ Cadastro e autenticação
- ✅ CRUD de excursões
- ✅ Upload de imagens
- ✅ Gestão de inscritos
- ✅ Dashboard com métricas
- ✅ Sistema de notificações para clientes
- ✅ Controle de pagamentos

## 🛠 Stack Tecnológica

- **Framework**: Spring Boot 3.5.3
- **Linguagem**: Java 21
- **Banco de Dados**: PostgreSQL
- **Autenticação**: JWT
- **Pagamentos**: Mercado Pago SDK
- **Upload de Imagens**: Cloudinary
- **Notificações**: Firebase Cloud Messaging
- **Email**: Spring Mail + SendGrid
- **Migrations**: Flyway
- **Build**: Maven

## ⚙️ Configuração

### 1. Pré-requisitos
- Java 21+
- PostgreSQL 12+
- Maven 3.9+

### 2. Variáveis de Ambiente

```bash
# Database
DB_URL=jdbc:postgresql://localhost:5432/tourapp
DB_USER=tourapp
DB_PASSWORD=tourapp123

# JWT
JWT_SECRET=tourapp-super-secret-key-change-in-production
JWT_EXPIRATION=86400000

# Mercado Pago
MERCADOPAGO_ACCESS_TOKEN=seu_access_token
MERCADOPAGO_PUBLIC_KEY=sua_public_key
MERCADOPAGO_WEBHOOK_SECRET=seu_webhook_secret

# Cloudinary
CLOUDINARY_CLOUD_NAME=seu_cloud_name
CLOUDINARY_API_KEY=sua_api_key
CLOUDINARY_API_SECRET=seu_api_secret

# Firebase
FIREBASE_SERVICE_ACCOUNT_PATH=classpath:firebase-service-account.json

# Email
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=seu_email@gmail.com
MAIL_PASSWORD=sua_senha_app

# Frontend
FRONTEND_BASE_URL=http://localhost:3000
CORS_ORIGINS=http://localhost:3000,https://tourapp.vercel.app
```

### 3. Configuração do Banco

```sql
-- Criar banco
CREATE DATABASE tourapp;

-- Criar usuário
CREATE USER tourapp WITH PASSWORD 'tourapp123';
GRANT ALL PRIVILEGES ON DATABASE tourapp TO tourapp;
```

### 4. Executar Localmente

```bash
# Clonar o repositório
git clone <repo-url>
cd tourapp-backend

# Instalar dependências
mvn clean install

# Executar aplicação
mvn spring-boot:run
```

A aplicação estará disponível em `http://localhost:8080/api`

## 🚀 Deploy no Railway

### 1. Conectar Repositório
1. Acesse [Railway](https://railway.app)
2. Conecte seu repositório GitHub
3. Selecione o projeto

### 2. Configurar Variáveis
No Railway, configure todas as variáveis de ambiente listadas acima.

### 3. Configurar Banco PostgreSQL
1. Adicione o plugin PostgreSQL no Railway
2. Use as credenciais geradas nas variáveis `DB_*`

### 4. Deploy Automático
O Railway fará deploy automático a cada push na branch main.

## 📚 Documentação da API

### Endpoints Públicos

#### Autenticação
```http
POST /api/auth/login
POST /api/auth/cadastro/cliente
POST /api/auth/cadastro/organizador
POST /api/auth/refresh
```

#### Excursões Públicas
```http
GET /api/public/excursoes/{id}
POST /api/public/excursoes/{id}/inscricoes
```

### Endpoints do Cliente (Requer token)

```http
GET /api/cliente/perfil
PUT /api/cliente/perfil
GET /api/cliente/inscricoes
GET /api/cliente/inscricoes/{id}
PUT /api/cliente/notificacoes/push-token
PUT /api/cliente/notificacoes/configuracoes
```

### Endpoints do Organizador (Requer token)

#### Excursões
```http
GET /api/organizador/excursoes
POST /api/organizador/excursoes
GET /api/organizador/excursoes/{id}
PUT /api/organizador/excursoes/{id}
PATCH /api/organizador/excursoes/{id}/status
DELETE /api/organizador/excursoes/{id}
```

#### Dashboard e Gestão
```http
GET /api/organizador/perfil
PUT /api/organizador/perfil
GET /api/organizador/dashboard
GET /api/organizador/inscricoes
GET /api/organizador/excursoes/{id}/inscricoes
```

#### Notificações
```http
POST /api/organizador/notificacoes
POST /api/organizador/notificacoes/{id}/enviar
GET /api/organizador/notificacoes
GET /api/organizador/notificacoes/clientes/{excursaoId}
```

### Endpoints de Pagamento

```http
POST /api/pagamentos/pix
POST /api/pagamentos/cartao
```

## 🔧 Novos Recursos JDK 21 + Spring Boot 3.5.3

### Virtual Threads
```yaml
spring:
  threads:
    virtual:
      enabled: true
```

### HTTP/2 e Compressão
```yaml
server:
  http2:
    enabled: true
  compression:
    enabled: true
```

### Observabilidade
```http
GET /api/actuator/health
GET /api/actuator/metrics
GET /api/actuator/prometheus
```

## 🐳 Docker

```bash
# Build da imagem
docker build -t tourapp-backend .

# Executar container
docker run -p 8080:8080 \
  -e DB_URL=jdbc:postgresql://host:5432/tourapp \
  -e DB_USER=tourapp \
  -e DB_PASSWORD=tourapp123 \
  tourapp-backend
```

### Docker Compose

```bash
# Executar com docker-compose
docker-compose up -d
```

## 🚨 Troubleshooting

### Problemas Comuns

1. **Erro de conexão com banco**
   - Verifique se o PostgreSQL está rodando
   - Confirme as credenciais nas variáveis de ambiente

2. **JWT Token inválido**
   - Verifique se o `JWT_SECRET` está configurado
   - Confirme se o token não expirou

3. **Upload de imagens falhando**
   - Verifique as credenciais do Cloudinary
   - Confirme o tamanho do arquivo (max 10MB)

4. **Pagamentos não funcionando**
   - Verifique as credenciais do Mercado Pago
   - Confirme se o webhook está configurado

### Logs

```bash
# Ver logs no Railway
railway logs

# Logs locais
tail -f logs/tourapp.log
```

## 📞 Contato

Para dúvidas sobre o projeto, entre em contato através dos issues do GitHub.

//src/main/resources/application-dev.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/tourapp
    username: tourapp
    password: tourapp123
  
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: validate
  
  mail:
    host: smtp.gmail.com
    port: 587
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}

app:
  jwt:
    secret: tourapp-dev-secret-key
    expiration: 86400000
  
  mercadopago:
    sandbox: true
  
  cors:
    allowed-origins: http://localhost:3000

logging:
  level:
    br.com.tourapp: DEBUG
    org.springframework.security: DEBUG
    org.hibernate.SQL: DEBUG

//src/main/resources/application-prod.yml
spring:
  datasource:
    url: ${DB_URL}
    username: ${DB_USER}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
  
  jpa:
    show-sql: false
    hibernate:
      ddl-auto: validate

app:
  jwt:
    secret: ${JWT_SECRET}
    expiration: ${JWT_EXPIRATION:86400000}
  
  mercadopago:
    sandbox: false
  
  cors:
    allowed-origins: ${CORS_ORIGINS}

logging:
  level:
    br.com.tourapp: INFO
    org.springframework.security: WARN
  file:
    name: logs/tourapp.log

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus    // Getters e Setters
    public String getTitulo() { return titulo; }
    public void setTitulo(String titulo) { this.titulo = titulo; }

    public String getDescricao() { return descricao; }
    public void setDescricao(String descricao) { this.descricao = descricao; }

    public LocalDateTime getDataSaida() { return dataSaida; }
    public void setDataSaida(LocalDateTime dataSaida) { this.dataSaida = dataSaida; }

    public LocalDateTime getDataRetorno() { return dataRetorno; }
    public void setDataRetorno(LocalDateTime dataRetorno) { this.dataRetorno = dataRetorno; }

    public BigDecimal getPreco() { return preco; }
    public void setPreco(BigDecimal preco) { this.preco = preco; }

    public Integer getVagasTotal() { return vagasTotal; }
    public void setVagasTotal(Integer vagasTotal) { this.vagasTotal = vagasTotal; }

    public Integer getVagasOcupadas() { return vagasOcupadas; }
    public void setVagasOcupadas(Integer vagasOcupadas) { this.vagasOcupadas = vagasOcupadas; }

    public String getLocalSaida() { return localSaida; }
    public void setLocalSaida(String localSaida) { this.localSaida = localSaida; }

    public String getLocalDestino() { return localDestino; }
    public void setLocalDestino(String localDestino) { this.localDestino = localDestino; }

    public String getObservacoes() { return observacoes; }
    public void setObservacoes(String observacoes) { this.observacoes = observacoes; }

    public List<String> getImagens() { return imagens; }
    public void setImagens(List<String> imagens) { this.imagens = imagens; }

    public Boolean getAceitaPix() { return aceitaPix; }
    public void setAceitaPix(Boolean aceitaPix) { this.aceitaPix = aceitaPix; }

    public Boolean getAceitaCartao() { return aceitaCartao; }
    public void setAceitaCartao(Boolean aceitaCartao) { this.aceitaCartao = aceitaCartao; }

    public StatusExcursao getStatus() { return status; }
    public void setStatus(StatusExcursao status) { this.status = status; }

    public Organizador getOrganizador() { return organizador; }
    public void setOrganizador(Organizador organizador) { this.organizador = organizador; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Inscricao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusPagamento;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.util.List;

@Entity
@Table(name = "inscricoes")
public class Inscricao extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "excursao_id", nullable = false)
    private Excursao excursao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cliente_id", nullable = false)
    private Cliente cliente;

    @NotNull(message = "Valor pago é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor deve ser maior que zero")
    @Column(name = "valor_pago", nullable = false, precision = 10, scale = 2)
    private BigDecimal valorPago;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_pagamento", nullable = false)
    private StatusPagamento statusPagamento = StatusPagamento.PENDENTE;

    @Column(name = "observacoes_cliente", columnDefinition = "TEXT")
    private String observacoesCliente;

    @OneToMany(mappedBy = "inscricao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Pagamento> pagamentos;

    // Construtores
    public Inscricao() {}

    public Inscricao(Excursao excursao, Cliente cliente, BigDecimal valorPago) {
        this.excursao = excursao;
        this.cliente = cliente;
        this.valorPago = valorPago;
    }

    // Getters e Setters
    public Excursao getExcursao() { return excursao; }
    public void setExcursao(Excursao excursao) { this.excursao = excursao; }

    public Cliente getCliente() { return cliente; }
    public void setCliente(Cliente cliente) { this.cliente = cliente; }

    public BigDecimal getValorPago() { return valorPago; }
    public void setValorPago(BigDecimal valorPago) { this.valorPago = valorPago; }

    public StatusPagamento getStatusPagamento() { return statusPagamento; }
    public void setStatusPagamento(StatusPagamento statusPagamento) { this.statusPagamento = statusPagamento; }

    public String getObservacoesCliente() { return observacoesCliente; }
    public void setObservacoesCliente(String observacoesCliente) { this.observacoesCliente = observacoesCliente; }

    public List<Pagamento> getPagamentos() { return pagamentos; }
    public void setPagamentos(List<Pagamento> pagamentos) { this.pagamentos = pagamentos; }
}

//src/main/java/br/com/tourapp/entity/Pagamento.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.MetodoPagamento;
import br.com.tourapp.enums.StatusPagamento;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "pagamentos")
public class Pagamento extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inscricao_id", nullable = false)
    private Inscricao inscricao;

    @NotNull(message = "Valor é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal valor;

    @Enumerated(EnumType.STRING)
    @Column(name = "metodo_pagamento", nullable = false)
    private MetodoPagamento metodoPagamento;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPagamento status = StatusPagamento.PENDENTE;

    @Column(name = "mercadopago_payment_id")
    private String mercadoPagoPaymentId;

    @Column(name = "mercadopago_preference_id")
    private String mercadoPagoPreferenceId;

    @Column(name = "qr_code")
    private String qrCode;

    @Column(name = "qr_code_base64", columnDefinition = "TEXT")
    private String qrCodeBase64;

    @Column(name = "data_processamento")
    private LocalDateTime dataProcessamento;

    @Column(name = "data_vencimento")
    private LocalDateTime dataVencimento;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    // Construtores
    public Pagamento() {}

    public Pagamento(Inscricao inscricao, BigDecimal valor, MetodoPagamento metodoPagamento) {
        this.inscricao = inscricao;
        this.valor = valor;
        this.metodoPagamento = metodoPagamento;
    }

    // Getters e Setters
    public Inscricao getInscricao() { return inscricao; }
    public void setInscricao(Inscricao inscricao) { this.inscricao = inscricao; }

    public BigDecimal getValor() { return valor; }
    public void setValor(BigDecimal valor) { this.valor = valor; }

    public MetodoPagamento getMetodoPagamento() { return metodoPagamento; }
    public void setMetodoPagamento(MetodoPagamento metodoPagamento) { this.metodoPagamento = metodoPagamento; }

    public StatusPagamento getStatus() { return status; }
    public void setStatus(StatusPagamento status) { this.status = status; }

    public String getMercadoPagoPaymentId() { return mercadoPagoPaymentId; }
    public void setMercadoPagoPaymentId(String mercadoPagoPaymentId) { this.mercadoPagoPaymentId = mercadoPagoPaymentId; }

    public String getMercadoPagoPreferenceId() { return mercadoPagoPreferenceId; }
    public void setMercadoPagoPreferenceId(String mercadoPagoPreferenceId) { this.mercadoPagoPreferenceId = mercadoPagoPreferenceId; }

    public String getQrCode() { return qrCode; }
    public void setQrCode(String qrCode) { this.qrCode = qrCode; }

    public String getQrCodeBase64() { return qrCodeBase64; }
    public void setQrCodeBase64(String qrCodeBase64) { this.qrCodeBase64 = qrCodeBase64; }

    public LocalDateTime getDataProcessamento() { return dataProcessamento; }
    public void setDataProcessamento(LocalDateTime dataProcessamento) { this.dataProcessamento = dataProcessamento; }

    public LocalDateTime getDataVencimento() { return dataVencimento; }
    public void setDataVencimento(LocalDateTime dataVencimento) { this.dataVencimento = dataVencimento; }

    public String getObservacoes() { return observacoes; }
    public void setObservacoes(String observacoes) { this.observacoes = observacoes; }
}

//src/main/java/br/com/tourapp/entity/Notificacao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoNotificacao;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "notificacoes")
public class Notificacao extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "excursao_id")
    private Excursao excursao;

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 100, message = "Título deve ter entre 5 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String titulo;

    @NotBlank(message = "Mensagem é obrigatória")
    @Size(min = 10, max = 500, message = "Mensagem deve ter entre 10 e 500 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String mensagem;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TipoNotificacao tipo = TipoNotificacao.INFO;

    @Column(name = "enviada_em")
    private LocalDateTime enviadaEm;

    @ElementCollection
    @CollectionTable(name = "notificacao_clientes", joinColumns = @JoinColumn(name = "notificacao_id"))
    @Column(name = "cliente_id")
    private List<UUID> clientesAlvo;

    @Column(name = "enviar_para_todos", nullable = false)
    private Boolean enviarParaTodos = false;

    @Column(name = "enviada", nullable = false)
    private Boolean enviada = false;

    // Construtores
    public Notificacao() {}

    public Notificacao(Organizador organizador, String titulo, String mensagem, TipoNotificacao tipo) {
        this.organizador = organizador;
        this.titulo = titulo;
        this.mensagem = mensagem;
        this.tipo = tipo;
    }

    // Getters e Setters
    public Organizador getOrganizador() { return organizador; }
    public void setOrganizador(Organizador organizador) { this.organizador = organizador; }

    public Excursao getExcursao() { return excursao; }
    public void setExcursao(Excursao excursao) { this.excursao = excursao; }

    public String getTitulo() { return titulo; }
    public void setTitulo(String titulo) { this.titulo = titulo; }

    public String getMensagem() { return mensagem; }
    public void setMensagem(String mensagem) { this.mensagem = mensagem; }

    public TipoNotificacao getTipo() { return tipo; }
    public void setTipo(TipoNotificacao tipo) { this.tipo = tipo; }

    public LocalDateTime getEnviadaEm() { return enviadaEm; }
    public void setEnviadaEm(LocalDateTime enviadaEm) { this.enviadaEm = enviadaEm; }

    public List<UUID> getClientesAlvo() { return clientesAlvo; }
    public void setClientesAlvo(List<UUID> clientesAlvo) { this.clientesAlvo = clientesAlvo; }

    public Boolean getEnviarParaTodos() { return enviarParaTodos; }
    public void setEnviarParaTodos(Boolean enviarParaTodos) { this.enviarParaTodos = enviarParaTodos; }

    public Boolean getEnviada() { return enviada; }
    public void setEnviada(Boolean enviada) { this.enviada = enviada; }
}

//src/main/java/br/com/tourapp/config/SecurityConfig.java
package br.com.tourapp.config;

import br.com.tourapp.security.JwtAuthenticationFilter;
import br.com.tourapp.security.CustomUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(CustomUserDetailsService userDetailsService, 
                         JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // Endpoints públicos
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/webhook/**").permitAll()
                .requestMatchers("/health", "/actuator/health").permitAll()
                
                // Endpoints de organizador
                .requestMatchers("/organizador/**").hasRole("ORGANIZADOR")
                
                // Endpoints de cliente
                .requestMatchers("/cliente/**").hasRole("CLIENTE")
                
                // Endpoints administrativos (futuro)
                .requestMatchers("/admin/**").hasRole("ADMIN")
                
                // Todos os outros endpoints requerem autenticação
                .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

//src/main/java/br/com/tourapp/security/JwtUtil.java
package br.com.tourapp.security;

import br.com.tourapp.enums.TipoUsuario;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.expiration}")
    private int jwtExpiration;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUserId(String token) {
        return extractClaim(token, claims -> claims.get("userId", String.class));
    }

    public TipoUsuario extractTipoUsuario(String token) {
        String tipo = extractClaim(token, claims -> claims.get("tipoUsuario", String.class));
        return TipoUsuario.valueOf(tipo);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails, UUID userId, TipoUsuario tipoUsuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("tipoUsuario", tipoUsuario.name());
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSigningKey())
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}

//src/main/java/br/com/tourapp/security/JwtAuthenticationFilter.java
package br.com.tourapp.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request,
                                    @NonNull HttpServletResponse response,
                                    @NonNull FilterChain filterChain) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        userEmail = jwtUtil.extractUsername(jwt);

        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);

            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}

//src/main/java/br/com/tourapp/security/CustomUserDetailsService.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.repository.ClienteRepository;
import br.com.tourapp.repository.OrganizadorRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final ClienteRepository clienteRepository;
    private final OrganizadorRepository organizadorRepository;

    public CustomUserDetailsService(ClienteRepository clienteRepository, 
                                   OrganizadorRepository organizadorRepository) {
        this.clienteRepository = clienteRepository;
        this.organizadorRepository = organizadorRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // Primeiro tenta encontrar cliente
        Cliente cliente = clienteRepository.findByEmail(email).orElse(null);
        if (cliente != null) {
            return new SecurityUser(cliente);
        }

        // Se não encontrou cliente, tenta organizador
        Organizador organizador = organizadorRepository.findByEmail(email).orElse(null);
        if (organizador != null) {
            return new SecurityUser(organizador);
        }

        throw new UsernameNotFoundException("Usuário não encontrado com email: " + email);
    }
}

//src/main/java/br/com/tourapp/security/SecurityUser.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.TipoUsuario;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.UUID;

public class SecurityUser implements UserDetails {

    private final UUID id;
    private final String email;
    private final String senha;
    private final String nome;
    private final TipoUsuario tipoUsuario;
    private final boolean ativo;

    public SecurityUser(Cliente cliente) {
        this.id = cliente.getId();
        this.email = cliente.getEmail();
        this.senha = cliente.getSenha();
        this.nome = cliente.getNome();
        this.tipoUsuario = cliente.getTipoUsuario();
        this.ativo = cliente.getAtivo();
    }

    public SecurityUser(Organizador organizador) {
        this.id = organizador.getId();
        this.email = organizador.getEmail();
        this.senha = organizador.getSenha();
        this.nome = organizador.getNomeEmpresa();
        this.tipoUsuario = organizador.getTipoUsuario();
        this.ativo = organizador.getStatus().name().equals("ATIVO");
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + tipoUsuario.name()));
    }

    @Override
    public String getPassword() {
        return senha;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return ativo;
    }

    // Getters adicionais
    public UUID getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    public String getNome() {
        return nome;
    }

    public TipoUsuario getTipoUsuario() {
        return tipoUsuario;
    }
}

//src/main/java/br/com/tourapp/repository/ClienteRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, UUID> {
    
    Optional<Cliente> findByEmail(String email);
    
    boolean existsByEmail(String email);
}

//src/main/java/br/com/tourapp/repository/OrganizadorRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.StatusOrganizador;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface OrganizadorRepository extends JpaRepository<Organizador, UUID> {
    
    Optional<Organizador> findByEmail(String email);
    
    boolean existsByEmail(String email);
    
    List<Organizador> findByStatus(StatusOrganizador status);
}

//src/main/java/br/com/tourapp/repository/ExcursaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Excursao;
import br.com.tourapp.enums.StatusExcursao;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ExcursaoRepository extends JpaRepository<Excursao, UUID> {
    
    Page<Excursao> findByOrganizadorId(UUID organizadorId, Pageable pageable);
    
    Page<Excursao> findByOrganizadorIdAndStatus(UUID organizadorId, StatusExcursao status, Pageable pageable);
    
    Optional<Excursao> findByIdAndOrganizadorId(UUID id, UUID organizadorId);
    
    List<Excursao> findByStatus(StatusExcursao status);
    
    @Query("SELECT e FROM Excursao e WHERE e.status = :status AND e.dataSaida BETWEEN :inicio AND :fim")
    List<Excursao> findByStatusAndDataSaidaBetween(@Param("status") StatusExcursao status, 
                                                   @Param("inicio") LocalDateTime inicio, 
                                                   @Param("fim") LocalDateTime fim);
}

//src/main/java/br/com/tourapp/repository/InscricaoRepository.java
package br.com.tourapp.repository;

import br.com.tourapp.entity.Inscricao;
import br.com.tourapp.enums.StatusPagamento;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.//pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.3</version>
        <relativePath/>
    </parent>
    
    <groupId>br.com.tourapp</groupId>
    <artifactId>tourapp-backend</artifactId>
    <version>1.0.0</version>
    <name>TourApp Backend</name>
    <description>Sistema de gerenciamento de excursões</description>
    
    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.6</version>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.6</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Mercado Pago SDK -->
        <dependency>
            <groupId>com.mercadopago</groupId>
            <artifactId>sdk-java</artifactId>
            <version>2.1.29</version>
        </dependency>
        
        <!-- Cloudinary -->
        <dependency>
            <groupId>com.cloudinary</groupId>
            <artifactId>cloudinary-http45</artifactId>
            <version>2.5.1</version>
        </dependency>
        
        <!-- Firebase Admin -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.4.1</version>
        </dependency>
        
        <!-- Utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>3.2.1</version>
        </dependency>
        
        <!-- Micrometer para métricas -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>
        
        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <configuration>
                    <url>${DB_URL}</url>
                    <user>${DB_USER}</user>
                    <password>${DB_PASSWORD}</password>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

//src/main/resources/application.yml
spring:
  application:
    name: tourapp
  
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  
  datasource:
    url: ${DB_URL:jdbc:postgresql://localhost:5432/tourapp}
    username: ${DB_USER:tourapp}
    password: ${DB_PASSWORD:tourapp123}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      connection-timeout: 20000
      validation-timeout: 5000
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
        use_sql_comments: true
    defer-datasource-initialization: false
  
  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration
    validate-on-migrate: true
  
  mail:
    host: ${MAIL_HOST:smtp.gmail.com}
    port: ${MAIL_PORT:587}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
  
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  
  # Virtual Threads (JDK 21 feature)
  threads:
    virtual:
      enabled: true

server:
  port: ${PORT:8080}
  servlet:
    context-path: /api
  # Habilitar HTTP/2 e compressão
  http2:
    enabled: true
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css
  error:
    include-stacktrace: never
    include-exception: false

# Configurações customizadas
app:
  jwt:
    secret: ${JWT_SECRET:tourapp-super-secret-key-change-in-production}
    expiration: ${JWT_EXPIRATION:86400000} # 24 horas em ms
  
  cors:
    allowed-origins: ${CORS_ORIGINS:http://localhost:3000,https://tourapp.vercel.app}
    allowed-methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
    allowed-headers: "*"
    allow-credentials: true
  
  mercadopago:
    access-token: ${MERCADOPAGO_ACCESS_TOKEN:}
    public-key: ${MERCADOPAGO_PUBLIC_KEY:}
    webhook-secret: ${MERCADOPAGO_WEBHOOK_SECRET:}
    sandbox: ${MERCADOPAGO_SANDBOX:true}
  
  cloudinary:
    cloud-name: ${CLOUDINARY_CLOUD_NAME:}
    api-key: ${CLOUDINARY_API_KEY:}
    api-secret: ${CLOUDINARY_API_SECRET:}
    secure: true
  
  firebase:
    service-account-path: ${FIREBASE_SERVICE_ACCOUNT_PATH:classpath:firebase-service-account.json}
  
  frontend:
    base-url: ${FRONTEND_BASE_URL:http://localhost:3000}
  
  file:
    upload-dir: ${UPLOAD_DIR:./uploads}
  
  cache:
    enabled: ${CACHE_ENABLED:true}
    ttl: ${CACHE_TTL:3600} # 1 hora

# Logging com melhor performance
logging:
  level:
    br.com.tourapp: ${LOG_LEVEL:INFO}
    org.springframework.security: ${SECURITY_LOG_LEVEL:WARN}
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: ${SQL_PARAMS_LOG_LEVEL:WARN}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: ${LOG_FILE:logs/tourapp.log}

# Management endpoints com security
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when_authorized
      show-components: when_authorized
    metrics:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

//src/main/java/br/com/tourapp/TourappApplication.java
package br.com.tourapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaAuditing
@EnableAsync
@EnableScheduling
public class TourappApplication {

    public static void main(String[] args) {
        SpringApplication.run(TourappApplication.class, args);
    }
}

//src/main/java/br/com/tourapp/entity/BaseEntity.java
package br.com.tourapp.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    // Getters e Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Long getVersion() {
        return version;
    }

    public void setVersion(Long version) {
        this.version = version;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BaseEntity)) return false;
        BaseEntity that = (BaseEntity) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}

//src/main/java/br/com/tourapp/enums/StatusOrganizador.java
package br.com.tourapp.enums;

public enum StatusOrganizador {
    PENDENTE("Pendente de aprovação"),
    ATIVO("Ativo"),
    INATIVO("Inativo"),
    SUSPENSO("Suspenso");

    private final String descricao;

    StatusOrganizador(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusExcursao.java
package br.com.tourapp.enums;

public enum StatusExcursao {
    RASCUNHO("Rascunho"),
    ATIVA("Ativa"),
    LOTADA("Lotada"),
    CANCELADA("Cancelada"),
    FINALIZADA("Finalizada");

    private final String descricao;

    StatusExcursao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/StatusPagamento.java
package br.com.tourapp.enums;

public enum StatusPagamento {
    PENDENTE("Pendente"),
    PROCESSANDO("Processando"),
    APROVADO("Aprovado"),
    REJEITADO("Rejeitado"),
    CANCELADO("Cancelado"),
    REEMBOLSADO("Reembolsado"),
    EXPIRADO("Expirado");

    private final String descricao;

    StatusPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/MetodoPagamento.java
package br.com.tourapp.enums;

public enum MetodoPagamento {
    PIX("PIX"),
    CARTAO_CREDITO("Cartão de Crédito"),
    CARTAO_DEBITO("Cartão de Débito"),
    BOLETO("Boleto"),
    DINHEIRO("Dinheiro");

    private final String descricao;

    MetodoPagamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoNotificacao.java
package br.com.tourapp.enums;

public enum TipoNotificacao {
    INFO("Informação"),
    PROMOCAO("Promoção"),
    LEMBRETE("Lembrete"),
    URGENTE("Urgente"),
    CONFIRMACAO("Confirmação"),
    CANCELAMENTO("Cancelamento");

    private final String descricao;

    TipoNotificacao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/enums/TipoUsuario.java
package br.com.tourapp.enums;

public enum TipoUsuario {
    CLIENTE("Cliente"),
    ORGANIZADOR("Organizador"),
    ADMIN("Administrador");

    private final String descricao;

    TipoUsuario(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

//src/main/java/br/com/tourapp/entity/Cliente.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "clientes")
public class Cliente extends BaseEntity {

    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    @Column(nullable = false, length = 100)
    private String nome;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "push_token")
    private String pushToken;

    @Column(name = "email_notifications", nullable = false)
    private Boolean emailNotifications = true;

    @Column(name = "sms_notifications", nullable = false)
    private Boolean smsNotifications = true;

    @Column(name = "ativo", nullable = false)
    private Boolean ativo = true;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.CLIENTE;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Cliente() {}

    public Cliente(String nome, String email, String senha) {
        this.nome = nome;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPushToken() { return pushToken; }
    public void setPushToken(String pushToken) { this.pushToken = pushToken; }

    public Boolean getEmailNotifications() { return emailNotifications; }
    public void setEmailNotifications(Boolean emailNotifications) { this.emailNotifications = emailNotifications; }

    public Boolean getSmsNotifications() { return smsNotifications; }
    public void setSmsNotifications(Boolean smsNotifications) { this.smsNotifications = smsNotifications; }

    public Boolean getAtivo() { return ativo; }
    public void setAtivo(Boolean ativo) { this.ativo = ativo; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Inscricao> getInscricoes() { return inscricoes; }
    public void setInscricoes(List<Inscricao> inscricoes) { this.inscricoes = inscricoes; }
}

//src/main/java/br/com/tourapp/entity/Organizador.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusOrganizador;
import br.com.tourapp.enums.TipoUsuario;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

@Entity
@Table(name = "organizadores")
public class Organizador extends BaseEntity {

    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 150, message = "Nome da empresa deve ter entre 2 e 150 caracteres")
    @Column(name = "nome_empresa", nullable = false, length = 150)
    private String nomeEmpresa;

    @NotBlank(message = "Nome do responsável é obrigatório")
    @Size(min = 2, max = 100, message = "Nome do responsável deve ter entre 2 e 100 caracteres")
    @Column(name = "nome_responsavel", nullable = false, length = 100)
    private String nomeResponsavel;

    @Email(message = "Email deve ser válido")
    @NotBlank(message = "Email é obrigatório")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 6, message = "Senha deve ter pelo menos 6 caracteres")
    @Column(nullable = false)
    private String senha;

    @Size(max = 20, message = "Telefone deve ter no máximo 20 caracteres")
    @Column(length = 20)
    private String telefone;

    @Column(name = "pix_key", length = 100)
    private String pixKey;

    @Size(max = 18, message = "CNPJ deve ter no máximo 18 caracteres")
    @Column(length = 18)
    private String cnpj;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusOrganizador status = StatusOrganizador.PENDENTE;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_usuario", nullable = false)
    private TipoUsuario tipoUsuario = TipoUsuario.ORGANIZADOR;

    @OneToMany(mappedBy = "organizador", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Excursao> excursoes;

    // Construtores
    public Organizador() {}

    public Organizador(String nomeEmpresa, String nomeResponsavel, String email, String senha) {
        this.nomeEmpresa = nomeEmpresa;
        this.nomeResponsavel = nomeResponsavel;
        this.email = email;
        this.senha = senha;
    }

    // Getters e Setters
    public String getNomeEmpresa() { return nomeEmpresa; }
    public void setNomeEmpresa(String nomeEmpresa) { this.nomeEmpresa = nomeEmpresa; }

    public String getNomeResponsavel() { return nomeResponsavel; }
    public void setNomeResponsavel(String nomeResponsavel) { this.nomeResponsavel = nomeResponsavel; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getSenha() { return senha; }
    public void setSenha(String senha) { this.senha = senha; }

    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }

    public String getPixKey() { return pixKey; }
    public void setPixKey(String pixKey) { this.pixKey = pixKey; }

    public String getCnpj() { return cnpj; }
    public void setCnpj(String cnpj) { this.cnpj = cnpj; }

    public StatusOrganizador getStatus() { return status; }
    public void setStatus(StatusOrganizador status) { this.status = status; }

    public TipoUsuario getTipoUsuario() { return tipoUsuario; }
    public void setTipoUsuario(TipoUsuario tipoUsuario) { this.tipoUsuario = tipoUsuario; }

    public List<Excursao> getExcursoes() { return excursoes; }
    public void setExcursoes(List<Excursao> excursoes) { this.excursoes = excursoes; }
}

//src/main/java/br/com/tourapp/entity/Excursao.java
package br.com.tourapp.entity;

import br.com.tourapp.enums.StatusExcursao;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "excursoes")
public class Excursao extends BaseEntity {

    @NotBlank(message = "Título é obrigatório")
    @Size(min = 5, max = 200, message = "Título deve ter entre 5 e 200 caracteres")
    @Column(nullable = false, length = 200)
    private String titulo;

    @NotBlank(message = "Descrição é obrigatória")
    @Size(min = 10, max = 2000, message = "Descrição deve ter entre 10 e 2000 caracteres")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String descricao;

    @NotNull(message = "Data de saída é obrigatória")
    @Future(message = "Data de saída deve ser no futuro")
    @Column(name = "data_saida", nullable = false)
    private LocalDateTime dataSaida;

    @Column(name = "data_retorno")
    private LocalDateTime dataRetorno;

    @NotNull(message = "Preço é obrigatório")
    @DecimalMin(value = "0.01", message = "Preço deve ser maior que zero")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal preco;

    @NotNull(message = "Total de vagas é obrigatório")
    @Min(value = 1, message = "Deve ter pelo menos 1 vaga")
    @Column(name = "vagas_total", nullable = false)
    private Integer vagasTotal;

    @Column(name = "vagas_ocupadas", nullable = false)
    private Integer vagasOcupadas = 0;

    @Column(name = "local_saida", length = 300)
    private String localSaida;

    @Column(name = "local_destino", length = 300)
    private String localDestino;

    @Column(name = "observacoes", columnDefinition = "TEXT")
    private String observacoes;

    @ElementCollection
    @CollectionTable(name = "excursao_imagens", joinColumns = @JoinColumn(name = "excursao_id"))
    @Column(name = "url_imagem")
    private List<String> imagens;

    @Column(name = "aceita_pix", nullable = false)
    private Boolean aceitaPix = true;

    @Column(name = "aceita_cartao", nullable = false)
    private Boolean aceitaCartao = true;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusExcursao status = StatusExcursao.RASCUNHO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "organizador_id", nullable = false)
    private Organizador organizador;

    @OneToMany(mappedBy = "excursao", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Inscricao> inscricoes;

    // Construtores
    public Excursao() {}

    public Excursao(String titulo, String descricao, LocalDateTime dataSaida, BigDecimal preco, 
                    Integer vagasTotal, Organizador organizador) {
        this.titulo = titulo;
        this.descricao = descricao;
        this.dataSaida = dataSaida;
        this.preco = preco;
        this.vagasTotal = vagasTotal;
        this.organizador = organizador;
    }

    // Métodos auxiliares
    public Integer getVagasDisponiveis() {
        return vagasTotal - vagasOcupadas;
    }

    public boolean temVagasDisponiveis() {
        return getVagasDisponiveis() > 0;
    }

    public boolean isAtiva() {
        return status == StatusExcursao.ATIVA;
    }